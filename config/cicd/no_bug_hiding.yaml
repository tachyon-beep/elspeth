# No Bug-Hiding Enforcement Configuration
#
# This file configures the no_bug_hiding static analysis tool.
# It detects defensive programming patterns that hide bugs instead of fixing them.
#
# Philosophy:
#   - Inside the tent: fail fast, no patterns that mask bugs
#   - At boundaries: explicit validation allowed, but must be intentional and documented
#
# Key format: <file_path>:<rule_id>:<symbol_context>:line=<lineno>
#
# Rules:
#   R1: dict.get() usage - hides missing key bugs
#   R2: getattr() with default - hides missing attribute bugs
#   R3: hasattr() usage - branches around missing attributes
#   R4: broad exception handling without re-raise - suppresses bugs

version: 1

defaults:
  # Fail CI if an allowlist entry doesn't match any code (stale entry)
  fail_on_stale: true
  # Fail CI if an allowlist entry has expired
  fail_on_expired: true

allow_hits:

  # ============================================================
  # TUI TRUST BOUNDARY (Permanent)
  # ============================================================
  # These display Landscape data that may be incomplete for failed/partial
  # runs. Graceful degradation to default values is appropriate - users see
  # partial data rather than a crash. This is intentional UX design.
  # ============================================================

  # --- ExplainScreen exception handling ---
  - key: "tui/screens/explain_screen.py:R4:ExplainScreen:_load_pipeline_structure:line=165"
    owner: "architecture"
    reason: "Trust boundary: loading pipeline structure that may fail for corrupt/incomplete runs"
    safety: "Errors logged with exc_info; returns LoadingFailedState with error message"
    expires: null  # Permanent - intentional design

  - key: "tui/screens/explain_screen.py:R4:ExplainScreen:_load_node_state:line=265"
    owner: "architecture"
    reason: "Trust boundary: loading node state that may fail for incomplete audit trails"
    safety: "Errors logged with exc_info; returns None to detail panel"
    expires: null  # Permanent - intentional design

  # --- LineageTree ---
  # LineageTree now uses strict LineageData TypedDict contract (Task 10).
  # No allowlist entries needed - callers must provide valid data.

  # --- NodeDetailPanel displaying node state ---
  # NOTE: plugin_name, node_type, and node_id are now REQUIRED fields (direct access).
  # The following entries are for OPTIONAL fields that use .get() + explicit fallback.

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=56"
    owner: "architecture"
    reason: "Optional field: state_id may be missing before execution"
    safety: "Graceful degradation to 'N/A' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=59"
    owner: "architecture"
    reason: "Optional field: token_id may be missing before execution"
    safety: "Graceful degradation to 'N/A' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=64"
    owner: "architecture"
    reason: "Optional field: status may be missing before execution"
    safety: "Graceful degradation to 'N/A' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=67"
    owner: "architecture"
    reason: "Optional field: started_at may be missing before execution"
    safety: "Graceful degradation to 'N/A' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=69"
    owner: "architecture"
    reason: "Optional field: completed_at may be missing before execution"
    safety: "Graceful degradation to 'N/A' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=71"
    owner: "architecture"
    reason: "Optional field: duration_ms may be missing before execution"
    safety: "Graceful degradation - conditionally displayed"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=78"
    owner: "architecture"
    reason: "Optional field: input_hash may be missing before execution"
    safety: "Graceful degradation to '(none)' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=79"
    owner: "architecture"
    reason: "Optional field: output_hash may be missing before execution"
    safety: "Graceful degradation to '(none)' - user sees partial data"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=86"
    owner: "architecture"
    reason: "Optional field: error_json may be missing"
    safety: "Graceful degradation - error section conditionally shown"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=98"
    owner: "architecture"
    reason: "Trust boundary: displaying error type from JSON that may be malformed"
    safety: "Graceful degradation to 'unknown' - user sees partial error info"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=99"
    owner: "architecture"
    reason: "Trust boundary: displaying error message from JSON that may be malformed"
    safety: "Graceful degradation to 'unknown' - user sees partial error info"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=110"
    owner: "architecture"
    reason: "Trust boundary: state_id lookup for logging context"
    safety: "None is safe - just means unknown state_id in log message"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=119"
    owner: "architecture"
    reason: "Optional field: artifact may be missing for non-sink nodes"
    safety: "Graceful degradation - artifact section conditionally shown"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=125"
    owner: "architecture"
    reason: "Trust boundary: displaying artifact_id that may be malformed"
    safety: "Graceful degradation to 'N/A' - user sees partial artifact info"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=126"
    owner: "architecture"
    reason: "Trust boundary: displaying path_or_uri that may be malformed"
    safety: "Graceful degradation to 'N/A' - user sees partial artifact info"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=127"
    owner: "architecture"
    reason: "Trust boundary: displaying content_hash that may be malformed"
    safety: "Graceful degradation to 'N/A' - user sees partial artifact info"
    expires: null  # Permanent - intentional design

  - key: "tui/widgets/node_detail.py:R1:NodeDetailPanel:render_content:line=131"
    owner: "architecture"
    reason: "Trust boundary: displaying size_bytes that may be malformed"
    safety: "Graceful degradation - conditionally displayed"
    expires: null  # Permanent - intentional design

  # ============================================================
  # PLUGIN MANAGER OPTIONAL API (Permanent)
  # ============================================================
  # These methods return Optional[T] by design - the documented API contract
  # is that callers check the return value. Returning None for unknown plugin
  # names is intentional, not a bug-hiding pattern.
  # ============================================================

  - key: "plugins/manager.py:R1:PluginManager:get_source_by_name:line=230"
    owner: "architecture"
    reason: "Intentional Optional API: returns None for unknown plugin names"
    safety: "Callers check return value - this is the documented contract"
    expires: null  # Permanent - intentional design

  - key: "plugins/manager.py:R1:PluginManager:get_transform_by_name:line=234"
    owner: "architecture"
    reason: "Intentional Optional API: returns None for unknown plugin names"
    safety: "Callers check return value - this is the documented contract"
    expires: null  # Permanent - intentional design

  - key: "plugins/manager.py:R1:PluginManager:get_gate_by_name:line=238"
    owner: "architecture"
    reason: "Intentional Optional API: returns None for unknown plugin names"
    safety: "Callers check return value - this is the documented contract"
    expires: null  # Permanent - intentional design

  # NOTE: get_aggregation_by_name and get_coalesce_by_name DELETED
  # Aggregation and coalesce lookups are now engine-controlled (WP-06, WP-08)

  - key: "plugins/manager.py:R1:PluginManager:get_sink_by_name:line=242"
    owner: "architecture"
    reason: "Intentional Optional API: returns None for unknown plugin names"
    safety: "Callers check return value - this is the documented contract"
    expires: null  # Permanent - intentional design

  # ============================================================
  # TRANSFORM/GATE CLEANUP (Permanent)
  # ============================================================
  # The orchestrator calls close() on transforms/gates in a finally block.
  # Cleanup should be best-effort - one plugin failure shouldn't crash the
  # whole cleanup process.
  # ============================================================

  - key: "engine/orchestrator.py:R4:Orchestrator:_cleanup_transforms:line=194"
    owner: "architecture"
    reason: "Best-effort cleanup: one plugin failure shouldn't prevent others from cleanup"
    safety: "Logged with warning, other plugins still get close() called"
    expires: null  # Permanent - intentional design

  # ============================================================
  # ROUTE VALIDATION (Permanent)
  # ============================================================
  # Route validation builds a lookup from node_id to gate name for error
  # messages. These lookups are for UI/diagnostic purposes only.
  # ============================================================

  - key: "engine/orchestrator.py:R1:Orchestrator:_validate_route_destinations:line=231"
    owner: "architecture"
    reason: "Building lookup for gate names - only gates (not transforms) are in map"
    safety: "None means 'not a gate at this sequence' - correctly skipped"
    expires: null  # Permanent - intentional design

  - key: "engine/orchestrator.py:R1:Orchestrator:_validate_route_destinations:line=238"
    owner: "architecture"
    reason: "Building lookup for config gate names"
    safety: "None means 'not a config gate at this name' - correctly skipped"
    expires: null  # Permanent - intentional design

  - key: "engine/orchestrator.py:R1:Orchestrator:_validate_route_destinations:line=254"
    owner: "architecture"
    reason: "Fallback for error message - use node_id if gate name not found"
    safety: "Error message still produced with node_id as fallback"
    expires: null  # Permanent - intentional design

  # ============================================================
  # SOURCE QUARANTINE VALIDATION (Permanent)
  # ============================================================
  # Source quarantine destination validation checks for optional protocol
  # extension. Not all sources define _on_validation_failure - only those
  # that inherit from SourceDataConfig (CSV, JSON, etc.).
  # ============================================================

  - key: "engine/orchestrator.py:R2:Orchestrator:_validate_source_quarantine_destination:line=327"
    owner: "architecture"
    reason: "Optional protocol extension - _on_validation_failure only on sources with SourceDataConfig"
    safety: "None default means source doesn't support quarantine routing - validation skipped"
    expires: null  # Permanent - intentional design

  # ============================================================
  # SCHEMA CONFIG LOOKUP (Permanent)
  # ============================================================
  # Schema config in node_info is optional - some nodes have explicit schemas,
  # others use dynamic. The default value is well-defined.
  # ============================================================

  - key: "engine/orchestrator.py:R1:Orchestrator:_execute_run:line=598"
    owner: "architecture"
    reason: "Optional schema config with explicit default - not all nodes define schemas"
    safety: "Default value is well-defined: dynamic fields"
    expires: null  # Permanent - intentional design


  # ============================================================
  # GATE ROUTING LOOKUPS (Permanent)
  # ============================================================
  # Gate executors look up routing destinations and edge IDs. Missing
  # entries raise MissingEdgeError with clear diagnostics.
  # ============================================================

  - key: "engine/executors.py:R1:GateExecutor:execute_gate:line=407"
    owner: "architecture"
    reason: "Lookup with explicit None check - raises MissingEdgeError if not found"
    safety: "Raises immediately with node_id and label for debugging"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:GateExecutor:_record_routing:line=682"
    owner: "architecture"
    reason: "Lookup with explicit None check - raises MissingEdgeError if not found"
    safety: "Raises immediately with node_id and label for debugging"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:GateExecutor:_record_routing:line=696"
    owner: "architecture"
    reason: "Lookup with explicit None check - raises MissingEdgeError if not found"
    safety: "Raises immediately with node_id and label for debugging"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AGGREGATION BUFFER METHODS (Permanent)
  # ============================================================
  # AggregationExecutor buffers rows internally for structural aggregation.
  # These lookups check if buffers exist for a node_id. Missing entries
  # are handled gracefully (return empty list or skip trigger update).
  # ============================================================

  - key: "engine/executors.py:R1:AggregationExecutor:buffer_row:line=783"
    owner: "architecture"
    reason: "Checking if batch exists to decide whether to create one"
    safety: "None means 'create new batch' - explicit conditional logic follows"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:buffer_row:line=808"
    owner: "architecture"
    reason: "Optional trigger evaluator lookup - not all aggregations have config"
    safety: "None means 'no trigger config' - correctly skipped"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:get_buffered_rows:line=821"
    owner: "architecture"
    reason: "Intentional Optional API: returns empty list for unknown node_id"
    safety: "Empty list is safe default - no rows buffered yet"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:get_buffered_tokens:line=832"
    owner: "architecture"
    reason: "Intentional Optional API: returns empty list for unknown node_id"
    safety: "Empty list is safe default - no tokens buffered yet"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:_get_buffered_data:line=847"
    owner: "architecture"
    reason: "Intentional Optional API: returns empty list for unknown node_id"
    safety: "Empty list is safe default - no rows buffered"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:_get_buffered_data:line=848"
    owner: "architecture"
    reason: "Intentional Optional API: returns empty list for unknown node_id"
    safety: "Empty list is safe default - no tokens buffered"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AGGREGATION CHECKPOINT METHODS (Permanent)
  # ============================================================
  # get_checkpoint_state() and restore_from_checkpoint() serialize/deserialize
  # buffer state for crash recovery. These use .get() for intentional reasons.
  # ============================================================

  - key: "engine/executors.py:R1:AggregationExecutor:execute_flush:line=1023"
    owner: "architecture"
    reason: "Optional trigger evaluator lookup - not all aggregations have trigger config"
    safety: "None means 'no trigger config' - correctly skipped"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:_reset_batch_state:line=1035"
    owner: "architecture"
    reason: "Idempotent cleanup: batch_id may not exist if already reset"
    safety: "None means 'already cleaned up or never existed' - correctly skipped"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:get_buffer_count:line=1050"
    owner: "architecture"
    reason: "Intentional Optional API: returns 0 for unknown node_id"
    safety: "0 is safe default - no rows buffered"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:get_checkpoint_state:line=1068"
    owner: "architecture"
    reason: "Intentional Optional: batch_id may not exist yet"
    safety: "None is valid for checkpoint state - no batch started yet"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:restore_from_checkpoint:line=1082"
    owner: "architecture"
    reason: "Trust boundary: checkpoint state from previous run may be malformed"
    safety: "Default empty list for missing rows - graceful recovery"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:restore_from_checkpoint:line=1083"
    owner: "architecture"
    reason: "Trust boundary: checkpoint state from previous run may be malformed"
    safety: "None batch_id means no batch to restore - graceful recovery"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:restore_from_checkpoint:line=1094"
    owner: "architecture"
    reason: "Optional trigger evaluator lookup - node may not have trigger config"
    safety: "None means 'no trigger config' - correctly skipped"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AGGREGATION BATCH STATE LOOKUPS (Permanent)
  # ============================================================
  # AggregationExecutor tracks batch IDs internally in _batch_ids dict.
  # These lookups check if a batch exists for a node_id. Missing entries
  # are valid (no batch yet) or raise ValueError with clear diagnostics.
  # ============================================================

  - key: "engine/executors.py:R1:AggregationExecutor:get_batch_id:line=1109"
    owner: "architecture"
    reason: "Intentional Optional API: returns None if no batch exists for node_id"
    safety: "Callers check return value - this is the documented contract"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:should_flush:line=1120"
    owner: "architecture"
    reason: "Intentional Optional API: returns False if no evaluator exists for node_id"
    safety: "No evaluator means no trigger config - return False is correct behavior"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:get_trigger_type:line=1134"
    owner: "architecture"
    reason: "Intentional Optional API: returns None if no evaluator exists for node_id"
    safety: "No evaluator means no trigger config - return None is correct behavior"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:get_restored_state:line=1163"
    owner: "architecture"
    reason: "Intentional Optional API: returns None if no state was restored for node_id"
    safety: "Callers check return value - None means 'not restored, use default state'"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AGGREGATION EXECUTE_FLUSH METHOD (Permanent)
  # ============================================================
  # execute_flush checks for existence of batch/buffers before proceeding.
  # Missing entries cause explicit RuntimeError with clear diagnostics.
  # ============================================================

  - key: "engine/executors.py:R1:AggregationExecutor:execute_flush:line=882"
    owner: "architecture"
    reason: "Explicit existence check: raises RuntimeError if batch_id is None"
    safety: "Raises immediately with node_id for debugging"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:execute_flush:line=887"
    owner: "architecture"
    reason: "Existence check paired with explicit RuntimeError if empty"
    safety: "Raises immediately if buffer is empty"
    expires: null  # Permanent - intentional design

  - key: "engine/executors.py:R1:AggregationExecutor:execute_flush:line=888"
    owner: "architecture"
    reason: "Token buffer lookup matches row buffer lookup pattern"
    safety: "Empty list default paired with row buffer check"
    expires: null  # Permanent - intentional design

  # ============================================================
  # PLUGIN METADATA EXTRACTION - MANAGER (Permanent)
  # ============================================================
  # These patterns extract optional attributes from plugins using getattr/hasattr.
  # Plugins may not define these optional attributes. This is legitimate duck-typing
  # at a plugin trust boundary. Required attributes (name, plugin_version) now
  # fail loudly if missing (Task 9).
  # ============================================================

  - key: "plugins/manager.py:R3:_schema_hash:line=49"
    owner: "architecture"
    reason: "Trust boundary: checking if plugin class has Pydantic model_fields"
    safety: "Raises TypeError if not Pydantic - fails fast on protocol violation"
    expires: null  # Permanent - intentional design

  # PluginSpec.from_plugin - schemas vary by plugin type (not all have both)
  # Sources only have output_schema, sinks only have input_schema
  - key: "plugins/manager.py:R2:PluginSpec:from_plugin:line=93"
    owner: "architecture"
    reason: "Polymorphic: sources don't have input_schema, sinks don't have output_schema"
    safety: "Legitimate Optional return - None means 'accepts any schema'"
    expires: null  # Permanent - intentional design

  - key: "plugins/manager.py:R2:PluginSpec:from_plugin:line=94"
    owner: "architecture"
    reason: "Polymorphic: sources don't have input_schema, sinks don't have output_schema"
    safety: "Legitimate Optional return - None means 'accepts any schema'"
    expires: null  # Permanent - intentional design

  # PluginManager._refresh_caches
  # NOTE: Previously had allowlist entries for getattr(cls, 'name', cls.__name__)
  # fallbacks at lines 196, 206, 216, 226, 236, 246. These were REMOVED because:
  # - All 6 protocols require 'name: str' as a mandatory attribute
  # - The fallback hid protocol violations instead of failing fast
  # - Now uses direct cls.name access; missing name crashes immediately
  # Removed in WP-11 Task 4 (2026-01-18).

  # ============================================================
  # SCHEMA VALIDATION TRUST BOUNDARY (Permanent)
  # ============================================================
  # These patterns handle Pydantic validation errors and type introspection.
  # Pydantic errors are external data, type introspection is for error messages.
  # ============================================================

  - key: "contracts/data.py:R1:validate_row:line=101"
    owner: "architecture"
    reason: "Trust boundary: Pydantic error dict may not have 'input' key"
    safety: "Graceful handling - validation error message still produced"
    expires: null  # Permanent - intentional design

  - key: "contracts/schema.py:R1:SchemaConfig:from_dict:line=199"
    owner: "architecture"
    reason: "Round-trip serialization: to_dict() outputs mode='dynamic', from_dict() must accept it"
    safety: "Explicit check for serialized form before standard parsing - enables audit trail storage"
    expires: null  # Permanent - intentional design

  - key: "contracts/data.py:R3:_type_name:line=199"
    owner: "architecture"
    reason: "Type introspection: not all types have __name__ attribute"
    safety: "Graceful fallback to str() - error message still produced"
    expires: null  # Permanent - intentional design

  # ============================================================
  # RETRY CONFIG PARSING (Permanent)
  # ============================================================
  # RetryConfig.from_policy parses external configuration dicts.
  # This is a documented trust boundary where external config may have
  # invalid or missing values.
  # ============================================================

  - key: "engine/retry.py:R1:RetryConfig:from_policy:line=80"
    owner: "architecture"
    reason: "Trust boundary: external policy dict may have invalid/missing values"
    safety: "max() ensures minimum valid value, docstring documents this behavior"
    expires: null  # Permanent - intentional design

  - key: "engine/retry.py:R1:RetryConfig:from_policy:line=81"
    owner: "architecture"
    reason: "Trust boundary: external policy dict may have invalid/missing values"
    safety: "max() ensures minimum valid value, docstring documents this behavior"
    expires: null  # Permanent - intentional design

  - key: "engine/retry.py:R1:RetryConfig:from_policy:line=82"
    owner: "architecture"
    reason: "Trust boundary: external policy dict may have invalid/missing values"
    safety: "max() ensures minimum valid value, docstring documents this behavior"
    expires: null  # Permanent - intentional design

  - key: "engine/retry.py:R1:RetryConfig:from_policy:line=83"
    owner: "architecture"
    reason: "Trust boundary: external policy dict may have invalid/missing values"
    safety: "max() ensures minimum valid value, docstring documents this behavior"
    expires: null  # Permanent - intentional design

  # ============================================================
  # ROW PROCESSOR PLUGIN DISPATCH
  # ============================================================
  # Previously used hasattr duck-typing. Now uses isinstance() checks
  # against base classes (BaseTransform, BaseGate).
  # Note: BaseAggregation was deleted in aggregation structural cleanup.
  # Aggregation is now engine-controlled via batch-aware transforms.
  # Stale allowlist entries removed by Task 7.
  # ============================================================

  # ============================================================
  # COALESCE STEP MAPPING (Permanent)
  # ============================================================
  # Fork children look up their coalesce info from _branch_to_coalesce
  # and _coalesce_step_map. The coalesce_name comes from our mapping,
  # but the step map might not have an entry if the step wasn't computed
  # yet (forward-compatibility for incremental integration).
  # ============================================================

  - key: "engine/processor.py:R1:RowProcessor:_process_single_token:line=706"
    owner: "architecture"
    reason: "Forward-compatibility: step map may not be fully populated during integration"
    safety: "None is valid - means coalesce step not yet computed, child skips coalesce"
    expires: null  # Permanent - intentional design

  - key: "engine/processor.py:R1:RowProcessor:_process_single_token:line=926"
    owner: "architecture"
    reason: "Forward-compatibility: step map may not be fully populated during integration"
    safety: "None is valid - means coalesce step not yet computed, child skips coalesce"
    expires: null  # Permanent - intentional design

  # ============================================================
  # CONFIG SECRET FINGERPRINTING (Permanent)
  # ============================================================
  # Optional environment variable for development mode override.
  # ELSPETH_ALLOW_RAW_SECRETS is not required - absence means "production mode".
  # ============================================================

  - key: "core/config.py:R1:_expand_env_vars:_expand_string:replacer:line=730"
    owner: "architecture"
    reason: "Trust boundary: environment variables are external input that may not exist"
    safety: "Explicit None check follows; falls back to default or keeps original for later error"
    expires: null  # Permanent - intentional design

  - key: "core/config.py:R1:_fingerprint_config_for_audit:line=992"
    owner: "architecture"
    reason: "Optional env var: ELSPETH_ALLOW_RAW_SECRETS is not required in production"
    safety: "Missing env var = empty string = False = production mode (fail-closed)"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AUDITED LLM CLIENT TRUST BOUNDARY (Permanent)
  # ============================================================
  # AuditedLLMClient wraps external LLM APIs (OpenAI, Azure, etc).
  # The usage dict comes from external APIs and may not include all fields.
  # The model_dump check is for SDK version compatibility.
  # ============================================================

  - key: "plugins/clients/llm.py:R1:LLMResponse:total_tokens:line=45"
    owner: "architecture"
    reason: "Trust boundary: LLM API usage dict may not include all token counts"
    safety: "Graceful default to 0 - total_tokens is convenience property, not critical"
    expires: null  # Permanent - intentional design

  - key: "plugins/clients/llm.py:R3:AuditedLLMClient:chat_completion:line=200"
    owner: "architecture"
    reason: "SDK version compatibility: older OpenAI SDK versions lack model_dump()"
    safety: "None is safe for raw_response - only used for debugging, not audit"
    expires: null  # Permanent - intentional design

  - key: "plugins/clients/http.py:R1:AuditedHTTPClient:post:line=161"
    owner: "architecture"
    reason: "Trust boundary: HTTP response headers from external server may lack content-type"
    safety: "Graceful default to empty string - treats as non-JSON, still records body"
    expires: null  # Permanent - intentional design

  - key: "plugins/clients/http.py:R4:AuditedHTTPClient:post:line=165"
    owner: "architecture"
    reason: "Trust boundary: external HTTP response may claim JSON but contain invalid JSON"
    safety: "Falls back to text storage - body is still recorded for audit"
    expires: null  # Permanent - intentional design

  # ============================================================
  # OPENROUTER LLM TRANSFORM TRUST BOUNDARY (Permanent)
  # ============================================================
  # OpenRouterLLMTransform wraps the OpenRouter HTTP API.
  # Response fields 'usage' and 'model' are optional per OpenRouter API docs.
  # ============================================================

  # --- _process_sequential() method (batch sequential fallback) ---
  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:_process_sequential:line=261"
    owner: "architecture"
    reason: "Trust boundary: HTTP response headers may not include content-type"
    safety: "Graceful default to 'unknown' - used for error reporting only"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:_process_sequential:line=286"
    owner: "architecture"
    reason: "Trust boundary: OpenRouter API 'usage' field is optional in response"
    safety: "Graceful default to {} - usage is metadata, not critical for processing"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:_process_sequential:line=297"
    owner: "architecture"
    reason: "Trust boundary: OpenRouter API may return different model than requested"
    safety: "Graceful fallback to requested model - audit still captures actual value"
    expires: null  # Permanent - intentional design

  # --- process() method ---
  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:process:line=478"
    owner: "architecture"
    reason: "Trust boundary: HTTP response headers may not include content-type"
    safety: "Graceful default to 'unknown' - used for error reporting only"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:process:line=505"
    owner: "architecture"
    reason: "Trust boundary: OpenRouter API 'usage' field is optional in response"
    safety: "Graceful default to {} - usage is metadata, not critical for processing"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:process:line=516"
    owner: "architecture"
    reason: "Trust boundary: OpenRouter API may return different model than requested"
    safety: "Graceful fallback to requested model - audit still captures actual value"
    expires: null  # Permanent - intentional design

  # --- _process_single_with_state() method (pooled execution) ---
  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:_process_single_with_state:line=621"
    owner: "architecture"
    reason: "Trust boundary: HTTP response headers may not include content-type"
    safety: "Graceful default to 'unknown' - used for error reporting only"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:_process_single_with_state:line=646"
    owner: "architecture"
    reason: "Trust boundary: OpenRouter API 'usage' field is optional in response"
    safety: "Graceful default to {} - usage is metadata, not critical for processing"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/openrouter.py:R1:OpenRouterLLMTransform:_process_single_with_state:line=657"
    owner: "architecture"
    reason: "Trust boundary: OpenRouter API may return different model than requested"
    safety: "Graceful fallback to requested model - audit still captures actual value"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AZURE BATCH LLM TRANSFORM (Permanent)
  # ============================================================
  # AzureBatchLLMTransform has two categories of defensive patterns:
  # 1. Checkpoint API capability check: Uses hasattr to verify PluginContext
  #    provides required checkpoint methods, then raises RuntimeError if missing.
  #    This is a required capability check, not forward-compatibility.
  # 2. Azure Batch API response parsing: External API responses may have
  #    different structures based on success/failure/version. These are
  #    external data at a trust boundary.
  # ============================================================

  # --- Checkpoint API capability checks (fail-fast if missing) ---
  - key: "plugins/llm/azure_batch.py:R3:AzureBatchLLMTransform:_get_checkpoint:line=283"
    owner: "architecture"
    reason: "Capability check: verify checkpoint API exists before using it"
    safety: "Raises RuntimeError if method doesn't exist - fail-fast, not silent degradation"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R3:AzureBatchLLMTransform:_update_checkpoint:line=300"
    owner: "architecture"
    reason: "Capability check: verify checkpoint API exists before using it"
    safety: "Raises RuntimeError if method doesn't exist - fail-fast, not silent degradation"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R3:AzureBatchLLMTransform:_clear_checkpoint:line=316"
    owner: "architecture"
    reason: "Capability check: verify checkpoint API exists before using it"
    safety: "Raises RuntimeError if method doesn't exist - fail-fast, not silent degradation"
    expires: null  # Permanent - intentional design

  # --- Checkpoint data access ---
  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_process_batch:line=264"
    owner: "architecture"
    reason: "Checkpoint may be None or empty dict - checking for batch_id existence"
    safety: "None/missing batch_id means PHASE 1 (fresh submit), explicit logic follows"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_check_batch_status:line=536"
    owner: "architecture"
    reason: "submitted_at may not exist in old checkpoint format"
    safety: "Missing submitted_at skips timeout check - graceful degradation"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=581"
    owner: "architecture"
    reason: "row_mapping may not exist in corrupted checkpoint"
    safety: "Empty dict default allows graceful recovery - rows return with error"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=582"
    owner: "architecture"
    reason: "template_errors may not exist in old checkpoint format"
    safety: "Empty list default means no template errors tracked - graceful degradation"
    expires: null  # Permanent - intentional design

  # --- Reverse lookup for row index to custom_id ---
  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=634"
    owner: "architecture"
    reason: "Intentional Optional API: rows with template errors aren't in mapping"
    safety: "None is checked explicitly on next line with 'if custom_id is None'"
    expires: null  # Permanent - intentional design

  # --- Azure Batch API response trust boundary ---
  - key: "plugins/llm/azure_batch.py:R3:AzureBatchLLMTransform:_check_batch_status:line=508"
    owner: "architecture"
    reason: "Trust boundary: Azure batch.errors may not exist on all batch statuses"
    safety: "Graceful handling - error info still returned without detailed errors"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R2:AzureBatchLLMTransform:_check_batch_status:line=491"
    owner: "architecture"
    reason: "Trust boundary: Azure batch.output_file_id only exists on completed batches"
    safety: "Recorded as None in audit trail - field is informational only"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=650"
    owner: "architecture"
    reason: "Trust boundary: Azure batch result 'error' field is optional"
    safety: "Graceful handling - checks for error before extracting response"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=662"
    owner: "architecture"
    reason: "Trust boundary: Azure batch result 'response' field structure varies"
    safety: "Graceful default to {} - handles missing/malformed responses"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=663"
    owner: "architecture"
    reason: "Trust boundary: Azure batch response 'body' field may be missing"
    safety: "Graceful default to {} - handles missing/malformed responses"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=664"
    owner: "architecture"
    reason: "Trust boundary: Azure batch response 'choices' field may be missing"
    safety: "Graceful default to [] - explicit check for empty choices follows"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=667"
    owner: "architecture"
    reason: "Trust boundary: Azure choice 'message.content' structure may vary"
    safety: "Graceful default to '' - empty content is valid for audit trail"
    expires: null  # Permanent - intentional design

  - key: "plugins/llm/azure_batch.py:R1:AzureBatchLLMTransform:_download_results:line=668"
    owner: "architecture"
    reason: "Trust boundary: Azure response 'usage' field is optional"
    safety: "Graceful default to {} - usage is metadata, not critical"
    expires: null  # Permanent - intentional design

  # ============================================================
  # AZURE CONTENT SAFETY TRANSFORM (Permanent)
  # ============================================================
  # AzureContentSafety analyzes text against Azure's Content Safety API.
  # API responses are external data (Tier 3: Zero Trust) and may not
  # include all expected categories. Missing categories default to
  # severity 0 (safe) to avoid false positives.
  # ============================================================

  - key: "plugins/transforms/azure/content_safety.py:R1:AzureContentSafety:_check_thresholds:line=586"
    owner: "architecture"
    reason: "Trust boundary: Azure API may not return all content categories (hate)"
    safety: "Graceful default to 0 (safe) - missing category is treated as 'not detected'"
    expires: null  # Permanent - intentional design

  - key: "plugins/transforms/azure/content_safety.py:R1:AzureContentSafety:_check_thresholds:line=590"
    owner: "architecture"
    reason: "Trust boundary: Azure API may not return all content categories (violence)"
    safety: "Graceful default to 0 (safe) - missing category is treated as 'not detected'"
    expires: null  # Permanent - intentional design

  - key: "plugins/transforms/azure/content_safety.py:R1:AzureContentSafety:_check_thresholds:line=594"
    owner: "architecture"
    reason: "Trust boundary: Azure API may not return all content categories (sexual)"
    safety: "Graceful default to 0 (safe) - missing category is treated as 'not detected'"
    expires: null  # Permanent - intentional design

  - key: "plugins/transforms/azure/content_safety.py:R1:AzureContentSafety:_check_thresholds:line=598"
    owner: "architecture"
    reason: "Trust boundary: Azure API may not return all content categories (self_harm)"
    safety: "Graceful default to 0 (safe) - missing category is treated as 'not detected'"
    expires: null  # Permanent - intentional design


  # ============================================================
  # AZURE PROMPT SHIELD TRANSFORM
  # ============================================================
  # AzurePromptShield uses FAIL-CLOSED security posture.
  # Malformed API responses raise errors (not silently pass content).
  # No allowlist entries needed - direct field access with try/except.
  # ============================================================

  # ============================================================
  # PLUGIN DISCOVERY TRUST BOUNDARY (Permanent)
  # ============================================================
  # Dynamic plugin discovery scans arbitrary Python files to find classes
  # that inherit from plugin base classes. We can't know at compile time
  # which classes have a `name` attribute - this is legitimate framework
  # polymorphism at a trust boundary.
  # ============================================================

  - key: "plugins/discovery.py:R2:_discover_in_file:line=126"
    owner: "architecture"
    reason: "Trust boundary: scanning arbitrary classes that may or may not have 'name' attribute"
    safety: "Classes without valid name are skipped with warning log - discovery continues"
    expires: null  # Permanent - intentional design

  - key: "plugins/discovery.py:R2:get_plugin_description:line=233"
    owner: "architecture"
    reason: "UI display fallback: generating human-readable description for classes without 'name' attr"
    safety: "Falls back to class __name__ for display - no control flow or audit impact"
    expires: null  # Permanent - intentional design

  # ============================================================
  # CLI HEALTH COMMAND TRUST BOUNDARY (Permanent)
  # ============================================================
  # The health command is a diagnostic tool for deployment verification.
  # It operates at system boundaries (environment variables, database
  # connections, filesystem access) and must gracefully handle failures
  # to report system state rather than crash.
  # ============================================================

  - key: "cli.py:R1:health:line=1007"
    owner: "architecture"
    reason: "Trust boundary: environment variable GIT_COMMIT_SHA is optional external input"
    safety: "Empty string default is safe - commit SHA is informational only"
    expires: null  # Permanent - intentional design

  - key: "cli.py:R4:health:line=1019"
    owner: "architecture"
    reason: "Trust boundary: git subprocess may fail for many reasons (not installed, not a repo, etc.)"
    safety: "Graceful fallback to 'unknown' - health check reports git as unavailable"
    expires: null  # Permanent - intentional design

  - key: "cli.py:R1:health:line=1035"
    owner: "architecture"
    reason: "Trust boundary: environment variable DATABASE_URL is optional external input"
    safety: "Empty string default triggers skip logic - database check only runs if configured"
    expires: null  # Permanent - intentional design

  - key: "cli.py:R4:health:line=1047"
    owner: "architecture"
    reason: "Trust boundary: database connection may fail for many reasons (network, auth, etc.)"
    safety: "Error recorded in checks dict with status='error' - health check reports DB as unhealthy"
    expires: null  # Permanent - intentional design

  - key: "cli.py:R4:health:line=1111"
    owner: "architecture"
    reason: "Trust boundary: plugin manager initialization may fail due to misconfiguration"
    safety: "Error recorded in checks dict with status='error' - health check reports plugins as unhealthy"
    expires: null  # Permanent - intentional design

  # ============================================================
  # FINGERPRINT KEY RETRIEVAL (Permanent)
  # ============================================================
  # get_fingerprint_key() checks optional environment variables to determine
  # which key source to use (env var vs Azure Key Vault). These are external
  # configuration inputs with explicit fallback logic - if neither is set,
  # ValueError is raised with clear guidance.
  # ============================================================

  - key: "core/security/fingerprint.py:R1:get_fingerprint_key:line=77"
    owner: "architecture"
    reason: "Trust boundary: ELSPETH_FINGERPRINT_KEY is optional external input (dev mode)"
    safety: "Explicit check: if not set, falls through to Key Vault check or raises ValueError"
    expires: null  # Permanent - intentional design

  - key: "core/security/fingerprint.py:R1:get_fingerprint_key:line=82"
    owner: "architecture"
    reason: "Trust boundary: ELSPETH_KEYVAULT_URL is optional external input (production mode)"
    safety: "Explicit check: if not set, raises ValueError with guidance on configuration"
    expires: null  # Permanent - intentional design

  - key: "core/security/fingerprint.py:R1:get_fingerprint_key:line=84"
    owner: "architecture"
    reason: "Trust boundary: ELSPETH_KEYVAULT_SECRET_NAME is optional with sensible default"
    safety: "Default 'elspeth-fingerprint-key' used when not set - documented behavior"
    expires: null  # Permanent - intentional design
