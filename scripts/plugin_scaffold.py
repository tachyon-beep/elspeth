#!/usr/bin/env python3
"""Utility to scaffold new plugin stubs.

Usage:
    python scripts/plugin_scaffold.py row my_custom_plugin

This generates a stub file with a basic registration schema. Use
`--directory` to override the output folder and `--force` to overwrite
existing files intentionally.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from textwrap import dedent
from typing import Callable, Dict

EXPERIMENT_PLUGINS_DIR = Path("src/elspeth/plugins/experiments")
OUTPUT_PLUGINS_DIR = Path("src/elspeth/plugins/outputs")
LLM_MIDDLEWARE_DIR = Path("src/elspeth/plugins/llms")

PLUGIN_DEFAULT_DIRS: Dict[str, Path] = {
    "row": EXPERIMENT_PLUGINS_DIR,
    "aggregator": EXPERIMENT_PLUGINS_DIR,
    "baseline": EXPERIMENT_PLUGINS_DIR,
    "sink": OUTPUT_PLUGINS_DIR,
    "middleware": LLM_MIDDLEWARE_DIR,
}


def to_class_name(identifier: str) -> str:
    parts = [segment for segment in identifier.replace("-", "_").split("_") if segment]
    return "".join(part.capitalize() for part in parts) or "Plugin"


def ensure_directory(path: Path) -> None:
    if not path.exists():
        path.mkdir(parents=True, exist_ok=True)


def row_template(name: str, class_name: str) -> str:
    return dedent(
        f'''
        """Row experiment plugin scaffold."""

        from __future__ import annotations

        from typing import Any, Dict

        from elspeth.core.experiments.plugin_registry import register_row_plugin


        class {class_name}:
            """Example row plugin generated by scaffold."""

            name = "{name}"

            def __init__(self, **options: Any) -> None:
                self.options = options

            def process_row(self, row: Dict[str, Any], responses: Dict[str, Any]) -> Dict[str, Any]:
                # TODO: implement plugin logic
                return {{}}


        register_row_plugin(
            "{name}",
            lambda options: {class_name}(**options),
            schema={{
                "type": "object",
                "properties": {{}},
                "additionalProperties": True,
            }},
        )
        '''
    ).strip()


def aggregator_template(name: str, class_name: str) -> str:
    return dedent(
        f'''
        """Aggregation plugin scaffold."""

        from __future__ import annotations

        from typing import Any, Dict, List

        from elspeth.core.experiments.plugin_registry import register_aggregation_plugin


        class {class_name}:
            """Example aggregator plugin generated by scaffold."""

            name = "{name}"

            def finalize(self, records: List[Dict[str, Any]]) -> Dict[str, Any]:
                # TODO: aggregate metrics across records
                return {{}}


        register_aggregation_plugin(
            "{name}",
            lambda options: {class_name}(),
            schema={{
                "type": "object",
                "properties": {{}},
                "additionalProperties": True,
            }},
        )
        '''
    ).strip()


def baseline_template(name: str, class_name: str) -> str:
    return dedent(
        f'''
        """Baseline comparison plugin scaffold."""

        from __future__ import annotations

        from typing import Any, Dict

        from elspeth.core.experiments.plugin_registry import register_baseline_plugin


        class {class_name}:
            """Example baseline plugin generated by scaffold."""

            name = "{name}"

            def compare(self, baseline: Dict[str, Any], variant: Dict[str, Any]) -> Dict[str, Any]:
                # TODO: compare baseline vs variant payloads
                return {{}}


        register_baseline_plugin(
            "{name}",
            lambda options: {class_name}(),
            schema={{
                "type": "object",
                "properties": {{}},
                "additionalProperties": True,
            }},
        )
        '''
    ).strip()


def sink_template(name: str, class_name: str) -> str:
    return dedent(
        f'''
        """Result sink scaffold."""

        from __future__ import annotations

        from pathlib import Path
        from typing import Any, Dict, Iterable

        from elspeth.core.interfaces import ResultSink, ArtifactDescriptor, Artifact


        class {class_name}(ResultSink):
            """Example result sink generated by scaffold."""

            def __init__(self, *, path: str, **options: Any) -> None:
                self.path = Path(path)
                self.options = options

            def write(self, results: Dict[str, Any], *, metadata: Dict[str, Any] | None = None) -> None:
                # TODO: serialize results to desired destination
                self.path.parent.mkdir(parents=True, exist_ok=True)
                self.path.write_text("TODO: write results", encoding="utf-8")

            def produces(self) -> Iterable[ArtifactDescriptor]:  # pragma: no cover - customize as needed
                return []

            def consumes(self) -> Iterable[str]:  # pragma: no cover
                return []

            def collect_artifacts(self) -> Dict[str, Artifact]:  # pragma: no cover
                return {{}}
        '''
    ).strip()


def middleware_template(name: str, class_name: str) -> str:
    return dedent(
        f'''
        """LLM middleware scaffold."""

        from __future__ import annotations

        from typing import Any, Dict

        from elspeth.core.llm.middleware import LLMMiddleware, LLMRequest
        from elspeth.core.llm.registry import register_middleware


        class {class_name}(LLMMiddleware):
            """Example middleware generated by scaffold."""

            name = "{name}"

            def __init__(self, **options: Any) -> None:
                self.options = options

            def before_request(self, request: LLMRequest) -> LLMRequest:
                # TODO: inspect/modify request
                return request

            def after_response(self, request: LLMRequest, response: Dict[str, Any]) -> Dict[str, Any]:
                # TODO: inspect/modify response
                return response


        register_middleware(
            "{name}",
            lambda options: {class_name}(**options),
            schema={{
                "type": "object",
                "properties": {{}},
                "additionalProperties": True,
            }},
        )
        '''
    ).strip()


TEMPLATES: Dict[str, Callable[[str, str], str]] = {
    "row": row_template,
    "aggregator": aggregator_template,
    "baseline": baseline_template,
    "sink": sink_template,
    "middleware": middleware_template,
}


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Scaffold plugin stubs")
    parser.add_argument("kind", choices=TEMPLATES.keys(), help="Plugin category to create")
    parser.add_argument("name", help="Plugin identifier, e.g., 'custom_metric'")
    parser.add_argument(
        "--directory",
        type=Path,
        help="Target directory (defaults to plugin family's package)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing file if it already exists",
    )
    args = parser.parse_args(argv)

    target_dir = args.directory or PLUGIN_DEFAULT_DIRS[args.kind]
    ensure_directory(target_dir)

    plugin_name = args.name.strip().lower()
    class_name = to_class_name(plugin_name)
    template = TEMPLATES[args.kind]
    contents = template(plugin_name, class_name)

    filename = f"{plugin_name}.py"
    destination = target_dir / filename
    if destination.exists() and not args.force:
        print(f"Error: {destination} already exists (use --force to overwrite)", file=sys.stderr)
        return 1

    destination.write_text(contents, encoding="utf-8")
    print(f"Created {destination}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
