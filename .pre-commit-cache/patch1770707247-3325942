diff --git a/tests/unit/engine/test_expression_parser.py b/tests/unit/engine/test_expression_parser.py
index 19d2ba9c..e0765b93 100644
--- a/tests/unit/engine/test_expression_parser.py
+++ b/tests/unit/engine/test_expression_parser.py
@@ -1348,3 +1348,51 @@ class TestExpressionEvaluationError:
         # Original KeyError should be chained
         assert exc_info.value.__cause__ is not None
         assert isinstance(exc_info.value.__cause__, KeyError)
+
+
+class TestExpressionValidatorFailClosed:
+    """Verify that the validator rejects unknown AST expression node types.
+
+    The _ExpressionValidator.visit() override (expression_parser.py:301-319)
+    provides defense-in-depth: any ast.expr subclass without an explicit
+    visit_* handler is rejected. This prevents future Python AST additions
+    from silently passing validation.
+    """
+
+    def test_unknown_ast_expr_node_rejected(self) -> None:
+        """Synthetic unknown AST expression node type is rejected."""
+        import ast as _ast
+
+        # Create a valid expression AST, then inject a synthetic node type
+        tree = _ast.parse("row['x']", mode="eval")
+
+        # Replace the body with an unknown expr subclass
+        class FakeExpr(_ast.expr):
+            _fields = ()
+
+        fake_node = FakeExpr()
+        fake_node.lineno = 1
+        fake_node.col_offset = 0
+        fake_node.end_lineno = 1
+        fake_node.end_col_offset = 1
+        tree.body = fake_node
+
+        # The validator should reject it via the fail-closed visit() override
+        from elspeth.engine.expression_parser import _ExpressionValidator
+
+        validator = _ExpressionValidator()
+        validator.visit(tree)
+        assert len(validator.errors) >= 1
+        assert "Unsupported expression construct" in validator.errors[0]
+        assert "FakeExpr" in validator.errors[0]
+
+    def test_structural_ast_nodes_not_blocked(self) -> None:
+        """Non-expression AST nodes (operators, contexts) pass through normally.
+
+        The fail-closed check only applies to ast.expr subclasses, not to
+        structural metadata like ast.Eq, ast.Load, ast.Expression, etc.
+        """
+        # This expression uses comparison ops, boolean ops, etc.
+        # If structural nodes were blocked, this would fail validation.
+        parser = ExpressionParser("row['a'] == 1 and row['b'] != 2")
+        assert parser.evaluate({"a": 1, "b": 3}) is True
