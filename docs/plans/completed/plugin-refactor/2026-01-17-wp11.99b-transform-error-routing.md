# WP-11.99b: Transform Error Routing

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Add configuration for transforms to specify where rows that cannot be processed are sent.

**Architecture:** Extend transform configuration with `on_error` destination for rows where the transform legitimately cannot complete processing (distinct from transform bugs, which crash). Builds on routing pattern established in WP-11.99a.

**Tech Stack:** Python 3.12, Pydantic, typing

---

## Key Architectural Decisions

| Decision | Rationale |
|----------|-----------|
| `on_error` is optional in config | Not all transforms can fail - pure mappings always succeed |
| Runtime error if transform errors without `on_error` | No hidden behavior - missing config + error = crash with clear message |
| `TransformResult.error()` triggers routing | Explicit signal from transform, not exception catching |
| Exceptions still crash | Transform bugs crash immediately per CLAUDE.md - this is for legitimate errors |
| Create `TransformDataConfig(DataPluginConfig)` | Scopes config to transforms (mirrors `SourceDataConfig` pattern from WP-11.99a) |

---

## Current Codebase Structure

**Config hierarchy (config_base.py):**
```
PluginConfig
    └── DataPluginConfig (requires schema)
            └── PathConfig (adds path validation)
            │       └── SourceDataConfig (adds on_validation_failure) [WP-11.99a]
            │               └── CSVSourceConfig, JSONSourceConfig
            └── TransformDataConfig (adds on_error) [THIS WP]
                    └── FieldMapperConfig, PassThroughConfig
```

**Existing transform structure:**
- `src/elspeth/plugins/transforms/field_mapper.py` → `FieldMapperConfig(DataPluginConfig)`
- `src/elspeth/plugins/transforms/passthrough.py` → `PassThroughConfig(DataPluginConfig)`

**Existing TransformResult (contracts/results.py:20):**
```python
@dataclass
class TransformResult:
    status: Literal["success", "error"]
    row: dict[str, Any] | None
    reason: dict[str, Any] | None  # Error details
    retryable: bool = False
```

**Engine structure:**
- `src/elspeth/engine/processor.py` → `RowProcessor` class
- `src/elspeth/engine/executors.py` → `TransformExecutor` class

---

## Error vs Bug Distinction

This is critical for understanding when `on_error` applies:

| Scenario | Signal | Behavior | Example |
|----------|--------|----------|---------|
| **Processing Error** | `TransformResult.error({"reason": "..."})` | Route to `on_error` sink | Division by zero, API rejection, business rule violation |
| **Transform Bug** | Exception thrown | CRASH immediately | AttributeError, TypeError in transform code |

```python
# PROCESSING ERROR - legitimate, uses on_error routing
def process(self, row: dict, ctx: PluginContext) -> TransformResult:
    if row["quantity"] == 0:
        return TransformResult.error({"reason": "Cannot calculate unit price: quantity is zero"})
    return TransformResult.success({"unit_price": row["total"] / row["quantity"]})

# TRANSFORM BUG - crashes, does NOT use on_error routing
def process(self, row: dict, ctx: PluginContext) -> TransformResult:
    return TransformResult.success({"value": row["nonexistent_field"]})  # KeyError = BUG
```

---

## Scope

**In scope:**
- Create `TransformDataConfig(DataPluginConfig)` with optional `on_error`
- Update `FieldMapperConfig`, `PassThroughConfig` to extend `TransformDataConfig`
- Route `TransformResult.error()` rows to configured sink
- Record transform errors in Landscape (extend existing validation_errors pattern)
- Runtime error if transform errors without `on_error` configured

**Out of scope:**
- Source validation (WP-11.99a - already done)
- Gate routing (gates route by design, not by error)
- Aggregation errors (different semantics - affects batches)

**Depends on:** WP-11.99 (config-driven schemas), WP-11.99a (establishes routing pattern)
**Risk:** Low - additive feature, clear error/bug distinction

---

## Task 1: Create TransformDataConfig

**Files:**
- Modify: `src/elspeth/plugins/config_base.py`
- Test: `tests/plugins/test_config_base.py`

**Step 1: Write failing tests**

Add to `tests/plugins/test_config_base.py`:

```python
"""Tests for transform error routing configuration."""

import pytest
from pydantic import ValidationError


class TestTransformDataConfig:
    """Tests for TransformDataConfig with on_error."""

    def test_on_error_is_optional(self) -> None:
        """on_error can be omitted for transforms that never error."""
        from elspeth.contracts.schema import SchemaConfig
        from elspeth.plugins.config_base import TransformDataConfig

        config = TransformDataConfig(
            schema_config=SchemaConfig(fields=["id: int"], mode="strict"),
        )

        assert config.on_error is None

    def test_on_error_accepts_sink_name(self) -> None:
        """on_error accepts a sink name."""
        from elspeth.contracts.schema import SchemaConfig
        from elspeth.plugins.config_base import TransformDataConfig

        config = TransformDataConfig(
            schema_config=SchemaConfig(fields=["id: int"], mode="strict"),
            on_error="failed_transforms",
        )

        assert config.on_error == "failed_transforms"

    def test_on_error_accepts_discard(self) -> None:
        """on_error accepts 'discard' for explicit drop."""
        from elspeth.contracts.schema import SchemaConfig
        from elspeth.plugins.config_base import TransformDataConfig

        config = TransformDataConfig(
            schema_config=SchemaConfig(fields=["id: int"], mode="strict"),
            on_error="discard",
        )

        assert config.on_error == "discard"

    def test_on_error_rejects_empty_string(self) -> None:
        """on_error rejects empty string - use None or valid sink."""
        from elspeth.contracts.schema import SchemaConfig
        from elspeth.plugins.config_base import TransformDataConfig

        with pytest.raises(ValidationError):
            TransformDataConfig(
                schema_config=SchemaConfig(fields=["id: int"], mode="strict"),
                on_error="",
            )

    def test_transform_config_inherits_schema_requirement(self) -> None:
        """TransformDataConfig inherits schema requirement from DataPluginConfig."""
        from elspeth.plugins.config_base import PluginConfigError, TransformDataConfig

        with pytest.raises(PluginConfigError, match="schema"):
            TransformDataConfig.from_dict({})
```

**Step 2: Implement TransformDataConfig**

Add to `config_base.py` after `PathConfig`:

```python
class TransformDataConfig(DataPluginConfig):
    """Base config for transform plugins with error routing.

    Extends DataPluginConfig to add optional on_error field.
    Transforms that can return TransformResult.error() should configure
    where those rows go.
    """

    on_error: str | None = Field(
        default=None,
        description="Sink name for rows that cannot be processed, or 'discard'. Required if transform can return errors.",
    )

    @field_validator("on_error")
    @classmethod
    def validate_on_error(cls, v: str | None) -> str | None:
        """Ensure on_error is not empty string."""
        if v is not None and not v.strip():
            raise ValueError("on_error must be a sink name, 'discard', or omitted entirely")
        return v.strip() if v else None
```

**Step 3: Run tests and commit**

```bash
pytest tests/plugins/test_config_base.py::TestTransformDataConfig -v
git add src/elspeth/plugins/config_base.py tests/plugins/test_config_base.py
git commit -m "$(cat <<'EOF'
feat(config): add TransformDataConfig with optional on_error

Transforms can now specify where errored rows go.
Optional because not all transforms can error.
Runtime check ensures errors don't silently disappear.

Part of WP-11.99b: Transform Error Routing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 2: Update Transform Configs to Use TransformDataConfig

**Files:**
- Modify: `src/elspeth/plugins/transforms/field_mapper.py`
- Modify: `src/elspeth/plugins/transforms/passthrough.py`
- Test: Existing tests should still pass

**Step 1: Update FieldMapperConfig**

Change:
```python
# OLD:
from elspeth.plugins.config_base import DataPluginConfig

class FieldMapperConfig(DataPluginConfig):

# NEW:
from elspeth.plugins.config_base import TransformDataConfig

class FieldMapperConfig(TransformDataConfig):
```

Also store the on_error config in `__init__`:
```python
def __init__(self, config: dict[str, Any]) -> None:
    super().__init__(config)
    cfg = FieldMapperConfig.from_dict(config)
    # ... existing code ...
    self._on_error = cfg.on_error  # NEW
```

**Step 2: Update PassThroughConfig similarly**

Change:
```python
# OLD:
from elspeth.plugins.config_base import DataPluginConfig

class PassThroughConfig(DataPluginConfig):

# NEW:
from elspeth.plugins.config_base import TransformDataConfig

class PassThroughConfig(TransformDataConfig):
```

**Step 3: Run existing tests**

```bash
pytest tests/plugins/transforms/ -v
```

Expected: All tests pass (on_error is optional, so existing configs still valid)

**Step 4: Commit**

```bash
git add src/elspeth/plugins/transforms/
git commit -m "$(cat <<'EOF'
refactor(transforms): use TransformDataConfig for error routing

FieldMapperConfig and PassThroughConfig now extend TransformDataConfig.
This enables optional on_error configuration for error routing.

Part of WP-11.99b: Transform Error Routing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 3: Add Transform Error Recording to Landscape

**Files:**
- Modify: `src/elspeth/plugins/context.py`
- Modify: `src/elspeth/core/landscape/recorder.py`
- Modify: `src/elspeth/core/landscape/schema.py`
- Test: `tests/plugins/test_context.py`, `tests/core/landscape/test_recorder.py`

**Step 1: Add TransformErrorToken to context.py**

```python
@dataclass
class TransformErrorToken:
    """Token returned when recording a transform error.

    Allows tracking the errored row through the audit trail.
    This is for LEGITIMATE processing errors, not transform bugs.
    """

    token_id: str
    transform_id: str
    error_id: str | None = None  # Set if recorded to landscape
    destination: str = "discard"  # Sink name or "discard"
```

**Step 2: Add record_transform_error to PluginContext**

```python
def record_transform_error(
    self,
    token_id: str,
    transform_id: str,
    row: dict[str, Any],
    error_details: dict[str, Any],
    destination: str,
) -> TransformErrorToken:
    """Record a transform processing error for audit trail.

    Called when a transform returns TransformResult.error().
    This is for legitimate errors, NOT transform bugs (which crash).

    Args:
        token_id: Token ID for the row being processed
        transform_id: Transform that returned the error
        row: The row data that could not be processed
        error_details: Error details from TransformResult.error()
        destination: Sink name where row is routed, or "discard"

    Returns:
        TransformErrorToken for tracking
    """
    if self.landscape is None:
        logger.warning(
            "Transform error not recorded (no landscape): %s - %s",
            transform_id,
            error_details,
        )
        return TransformErrorToken(
            token_id=token_id,
            transform_id=transform_id,
            destination=destination,
        )

    error_id = self.landscape.record_transform_error(
        run_id=self.run_id,
        token_id=token_id,
        transform_id=transform_id,
        row_data=row,
        error_details=error_details,
        destination=destination,
    )

    return TransformErrorToken(
        token_id=token_id,
        transform_id=transform_id,
        error_id=error_id,
        destination=destination,
    )
```

**Step 3: Add record_transform_error to LandscapeRecorder**

In `recorder.py`:

```python
def record_transform_error(
    self,
    run_id: str,
    token_id: str,
    transform_id: str,
    row_data: dict[str, Any],
    error_details: dict[str, Any],
    destination: str,
) -> str:
    """Record a transform processing error in the audit trail.

    Called when a transform returns TransformResult.error().
    This is for legitimate errors, NOT transform bugs.

    Args:
        run_id: Current run ID
        token_id: Token ID for the row
        transform_id: Transform that returned the error
        row_data: The row that could not be processed
        error_details: Error details from TransformResult
        destination: Where row was routed ("discard" or sink name)

    Returns:
        error_id for tracking
    """
    error_id = f"terr_{_generate_id()[:12]}"

    with self._db.connection() as conn:
        conn.execute(
            transform_errors_table.insert().values(
                error_id=error_id,
                run_id=run_id,
                token_id=token_id,
                transform_id=transform_id,
                row_hash=stable_hash(row_data),
                row_data_json=canonical_json(row_data),
                error_details_json=canonical_json(error_details),
                destination=destination,
                created_at=_now(),
            )
        )

    return error_id
```

**Step 4: Add transform_errors_table to schema.py**

```python
# === Transform Errors (WP-11.99b: Transform Error Routing) ===

transform_errors_table = Table(
    "transform_errors",
    metadata,
    Column("error_id", String(32), primary_key=True),
    Column("run_id", String(64), ForeignKey("runs.run_id"), nullable=False),
    Column("token_id", String(64), nullable=False),
    Column("transform_id", String(64), nullable=False),
    Column("row_hash", String(64), nullable=False),
    Column("row_data_json", Text),
    Column("error_details_json", Text),  # From TransformResult.error()
    Column("destination", String(255), nullable=False),  # Sink name or "discard"
    Column("created_at", DateTime(timezone=True), nullable=False),
)

Index("ix_transform_errors_run", transform_errors_table.c.run_id)
Index("ix_transform_errors_token", transform_errors_table.c.token_id)
Index("ix_transform_errors_transform", transform_errors_table.c.transform_id)
```

**Step 5: Write tests and commit**

```bash
pytest tests/plugins/test_context.py tests/core/landscape/test_recorder.py -v
git add src/elspeth/plugins/context.py src/elspeth/core/landscape/recorder.py src/elspeth/core/landscape/schema.py tests/
git commit -m "$(cat <<'EOF'
feat(landscape): add transform error recording

TransformErrorToken tracks where errored rows are routed.
New transform_errors_table stores error details for audit trail.
Distinct from validation_errors (source boundary) vs transform errors (pipeline).

Part of WP-11.99b: Transform Error Routing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 4: Implement Error Routing in TransformExecutor

**Files:**
- Modify: `src/elspeth/engine/executors.py`
- Test: `tests/engine/test_transform_error_routing.py`

**Step 1: Write tests for error routing**

Create `tests/engine/test_transform_error_routing.py`:

```python
"""Tests for transform error routing in engine."""

import pytest
from unittest.mock import MagicMock

from elspeth.contracts.results import TransformResult
from elspeth.plugins.context import PluginContext, TransformErrorToken


class MockTransform:
    """Mock transform for testing."""

    name = "mock_transform"

    def __init__(self, result: TransformResult, on_error: str | None = None) -> None:
        self._result = result
        self._on_error = on_error

    def process(self, row: dict, ctx: PluginContext) -> TransformResult:
        return self._result


class TestTransformErrorRouting:
    """Tests for routing TransformResult.error() rows."""

    @pytest.fixture
    def ctx(self) -> PluginContext:
        """Create minimal plugin context."""
        return PluginContext(run_id="test-run", config={}, node_id="test_node")

    def test_success_result_returns_row(self, ctx: PluginContext) -> None:
        """TransformResult.success() returns the transformed row."""
        from elspeth.engine.executors import TransformExecutor

        transform = MockTransform(TransformResult.success({"value": 42}))
        executor = TransformExecutor()

        result = executor.execute(
            transform=transform,
            row={"input": 1},
            token_id="tok_123",
            ctx=ctx,
        )

        assert result.status == "success"
        assert result.row == {"value": 42}

    def test_error_result_with_on_error_routes_to_sink(self, ctx: PluginContext) -> None:
        """TransformResult.error() with on_error routes to configured sink."""
        from elspeth.engine.executors import TransformExecutor

        transform = MockTransform(
            TransformResult.error({"reason": "Cannot process"}),
            on_error="error_sink",
        )

        # Track route_to_sink calls
        routed = []
        ctx.route_to_sink = lambda sink, row, metadata: routed.append({
            "sink": sink,
            "row": row,
        })

        # Mock record_transform_error
        ctx.record_transform_error = lambda **kwargs: TransformErrorToken(
            token_id=kwargs["token_id"],
            transform_id=kwargs["transform_id"],
            destination=kwargs["destination"],
        )

        executor = TransformExecutor()
        result = executor.execute(
            transform=transform,
            row={"input": 1},
            token_id="tok_123",
            ctx=ctx,
        )

        assert result.status == "error"
        assert len(routed) == 1
        assert routed[0]["sink"] == "error_sink"

    def test_error_result_with_discard_does_not_route(self, ctx: PluginContext) -> None:
        """TransformResult.error() with discard does NOT call route_to_sink."""
        from elspeth.engine.executors import TransformExecutor

        transform = MockTransform(
            TransformResult.error({"reason": "Cannot process"}),
            on_error="discard",
        )

        routed = []
        ctx.route_to_sink = lambda sink, row, metadata: routed.append(sink)
        ctx.record_transform_error = lambda **kwargs: TransformErrorToken(
            token_id="tok", transform_id="t", destination="discard"
        )

        executor = TransformExecutor()
        executor.execute(
            transform=transform,
            row={"input": 1},
            token_id="tok_123",
            ctx=ctx,
        )

        assert routed == []  # Nothing routed for discard

    def test_error_without_on_error_raises_configuration_error(
        self, ctx: PluginContext
    ) -> None:
        """TransformResult.error() without on_error raises ConfigurationError."""
        from elspeth.engine.executors import TransformExecutor

        transform = MockTransform(
            TransformResult.error({"reason": "Cannot process"}),
            on_error=None,  # Not configured
        )

        executor = TransformExecutor()

        with pytest.raises(RuntimeError, match="on_error"):
            executor.execute(
                transform=transform,
                row={"input": 1},
                token_id="tok_123",
                ctx=ctx,
            )

    def test_error_event_recorded_for_sink_destination(self, ctx: PluginContext) -> None:
        """record_transform_error called when routing to sink."""
        from elspeth.engine.executors import TransformExecutor

        transform = MockTransform(
            TransformResult.error({"reason": "Test error"}),
            on_error="error_sink",
        )

        recorded = []

        def capture_record(**kwargs):
            recorded.append(kwargs)
            return TransformErrorToken(
                token_id=kwargs["token_id"],
                transform_id=kwargs["transform_id"],
                destination=kwargs["destination"],
            )

        ctx.record_transform_error = capture_record
        ctx.route_to_sink = lambda sink, row, metadata: None

        executor = TransformExecutor()
        executor.execute(
            transform=transform,
            row={"input": 1},
            token_id="tok_123",
            ctx=ctx,
        )

        assert len(recorded) == 1
        assert recorded[0]["destination"] == "error_sink"
        assert recorded[0]["transform_id"] == "mock_transform"

    def test_error_event_recorded_for_discard(self, ctx: PluginContext) -> None:
        """record_transform_error called even when discarding."""
        from elspeth.engine.executors import TransformExecutor

        transform = MockTransform(
            TransformResult.error({"reason": "Test error"}),
            on_error="discard",
        )

        recorded_destinations = []

        ctx.record_transform_error = lambda **kwargs: (
            recorded_destinations.append(kwargs["destination"]),
            TransformErrorToken(token_id="t", transform_id="t", destination="discard"),
        )[1]

        executor = TransformExecutor()
        executor.execute(
            transform=transform,
            row={"input": 1},
            token_id="tok_123",
            ctx=ctx,
        )

        assert recorded_destinations == ["discard"]

    def test_exception_in_transform_propagates(self, ctx: PluginContext) -> None:
        """Exception in transform propagates (does NOT route to on_error)."""
        from elspeth.engine.executors import TransformExecutor

        class BuggyTransform:
            name = "buggy"
            _on_error = "error_sink"

            def process(self, row: dict, ctx: PluginContext) -> TransformResult:
                raise KeyError("nonexistent_field")  # BUG!

        executor = TransformExecutor()

        with pytest.raises(KeyError):
            executor.execute(
                transform=BuggyTransform(),
                row={"input": 1},
                token_id="tok_123",
                ctx=ctx,
            )
```

**Step 2: Update TransformExecutor to handle error routing**

In `executors.py`, update the `TransformExecutor.execute` method:

```python
def execute(
    self,
    transform: BaseTransform,
    row: dict[str, Any],
    token_id: str,
    ctx: PluginContext,
) -> TransformResult:
    """Execute transform on row, handling error routing.

    Returns:
        TransformResult (success or error)

    Raises:
        Exception: Transform bugs propagate immediately (not caught)
        RuntimeError: Transform errors without on_error config
    """
    # Let exceptions propagate - transform bugs should crash
    result = transform.process(row, ctx)

    if result.status == "success":
        return result

    if result.status == "error":
        on_error = getattr(transform, "_on_error", None)

        if on_error is None:
            raise RuntimeError(
                f"Transform '{transform.name}' returned error but has no on_error "
                f"configured. Either configure on_error or fix the transform to not "
                f"return errors for this input. Error: {result.reason}"
            )

        # Record event (always, even for discard)
        ctx.record_transform_error(
            token_id=token_id,
            transform_id=transform.name,
            row=row,
            error_details=result.reason or {},
            destination=on_error,
        )

        # Route to sink if not discarding
        if on_error != "discard":
            ctx.route_to_sink(
                sink_name=on_error,
                row=row,
                metadata={"transform_error": result.reason},
            )

        return result

    # Unknown status - this is a bug in the transform
    raise RuntimeError(f"Transform returned unknown status: {result.status}")
```

**Step 3: Run tests and commit**

```bash
pytest tests/engine/test_transform_error_routing.py -v
git add src/elspeth/engine/executors.py tests/engine/test_transform_error_routing.py
git commit -m "$(cat <<'EOF'
feat(engine): implement transform error routing

TransformExecutor now routes TransformResult.error() to configured sink.
RuntimeError if transform errors without on_error config.
Exceptions still crash - only explicit errors are routed.

Part of WP-11.99b: Transform Error Routing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 5: Final Verification

**Step 1: Run mypy**

```bash
mypy src/elspeth/plugins/config_base.py src/elspeth/plugins/transforms/ src/elspeth/engine/executors.py src/elspeth/plugins/context.py src/elspeth/core/landscape/recorder.py --strict
```

**Step 2: Run all tests**

```bash
pytest tests/plugins/ tests/engine/ tests/core/landscape/ -v
```

**Step 3: Verify error/bug distinction is enforced**

```bash
# Search for any exception catching that might hide transform bugs
grep -rn "except.*Exception" src/elspeth/engine/ | grep -v "ConfigurationError\|RuntimeError"
```

Expected: No broad exception catches that would hide transform bugs

---

## Verification Checklist

- [ ] `TransformDataConfig` created with optional `on_error`
- [ ] `FieldMapperConfig` and `PassThroughConfig` extend `TransformDataConfig`
- [ ] `TransformErrorToken` added to context.py
- [ ] `record_transform_error` takes and persists to `transform_errors_table`
- [ ] `transform_errors_table` created in schema.py
- [ ] `TransformExecutor` handles error routing
- [ ] Missing `on_error` + error = `RuntimeError` (not silent drop)
- [ ] Exceptions crash, not route (bug vs error distinction)
- [ ] All tests pass
- [ ] mypy clean

---

## Files Changed Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `src/elspeth/plugins/config_base.py` | MODIFY | Add `TransformDataConfig` class |
| `src/elspeth/plugins/transforms/field_mapper.py` | MODIFY | Use `TransformDataConfig` |
| `src/elspeth/plugins/transforms/passthrough.py` | MODIFY | Use `TransformDataConfig` |
| `src/elspeth/plugins/context.py` | MODIFY | Add `TransformErrorToken`, `record_transform_error` |
| `src/elspeth/core/landscape/recorder.py` | MODIFY | Add `record_transform_error` method |
| `src/elspeth/core/landscape/schema.py` | MODIFY | Add `transform_errors_table` |
| `src/elspeth/engine/executors.py` | MODIFY | Add error routing to `TransformExecutor` |
| `tests/plugins/test_config_base.py` | MODIFY | Add `TestTransformDataConfig` |
| `tests/engine/test_transform_error_routing.py` | CREATE | Error routing behavior tests |

---

## Configuration Example

```yaml
transforms:
  price_calculator:
    type: custom_transform
    schema:
      mode: strict
      fields:
        - "quantity: int"
        - "total: float"
    on_error: calculation_errors  # Rows with division-by-zero, etc.

  field_mapper:
    type: field_mapper
    schema:
      fields: dynamic
    mapping:
      old_name: new_name
    # on_error omitted - field_mapper never returns errors

sinks:
  calculation_errors:
    type: json_sink
    path: output/errors/calculations.jsonl
    schema:
      fields: dynamic
    on_validation_failure: discard
```

**Important:** `on_error: discard` means the row is DROPPED, not that it continues without the transform's changes. If you want "best effort" transforms that let rows through on failure, the transform should return `TransformResult.success()` with whatever partial result is acceptable.

---

## Dependency Notes

- **Depends on:** WP-11.99 (config patterns), WP-11.99a (routing pattern, `route_to_sink`)
- **Unlocks:** Complete transform-level audit trail
- **Risk:** Low - additive feature, clear semantics
- **Estimated Effort:** 2-3 hours
