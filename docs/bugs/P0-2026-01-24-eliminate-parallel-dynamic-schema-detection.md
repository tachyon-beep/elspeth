# Bug Report: Eliminate parallel dynamic schema detection mechanisms (Technical Debt)

## Summary

- Dynamic schema detection uses introspection of Pydantic model structure instead of the source of truth (`SchemaConfig.is_dynamic`)
- Creates redundant detection mechanisms: `SchemaConfig.is_dynamic` (config layer) vs `_is_dynamic_schema()` (DAG layer)
- Couples DAG validation to Pydantic implementation details (`model_fields`, `model_config`)
- Root cause: DAG layer receives only Pydantic schema classes, losing access to `SchemaConfig` metadata
- This is **architectural debt** from P0-2026-01-24-dynamic-schema-detection-regression fix
- Current implementation is **functionally correct** but has **poor long-term maintainability**

## Severity

- Severity: **high** (architectural debt that will compound over time)
- Priority: **P0** (must fix post-RC-1 before further schema-related work)
- Category: **Technical Debt / Architectural Improvement**

## Reporter

- Name or handle: axiom-system-architect:architecture-critic (agent a21a5df)
- Date: 2026-01-24
- Related issue ID: P0-2026-01-24-dynamic-schema-detection-regression (parent bug)
- Review session: Architecture review of dynamic schema detection fix

## Environment

- Commit/branch: `fix/rc1-bug-burndown-session-4` @ `3a60857`
- OS: Linux 6.8.0-90-generic
- Python version: 3.13.1
- Affected components: All schema validation in `ExecutionGraph`

## Problem Statement

### Current Architecture (As-Implemented)

```
┌─────────────────────────────────────────────────────────┐
│              CONFIGURATION LAYER                         │
│                                                          │
│  SchemaConfig                                            │
│  ├── is_dynamic: bool  ◄───── SOURCE OF TRUTH          │
│  ├── mode: "strict" | "free" | None                     │
│  └── fields: tuple[FieldDefinition, ...] | None         │
│                                                          │
│  Used by: Plugins (csv_sink, passthrough, etc.)         │
│  Detection: self._schema_config.is_dynamic              │
└─────────────────────────────────────────────────────────┘
                         │
                         │ schema_factory.create_schema_from_config()
                         ▼
┌─────────────────────────────────────────────────────────┐
│              PYDANTIC LAYER                              │
│                                                          │
│  type[PluginSchema]  (Pydantic model class)             │
│  ├── model_fields: dict[str, FieldInfo]                 │
│  ├── model_config: ConfigDict                           │
│  │   └── extra: "allow" | "forbid"                      │
│  └── [Generated by create_model()]                      │
│                                                          │
│  Dynamic schema characteristics:                        │
│  • model_fields == {}                                   │
│  • model_config['extra'] == 'allow'                     │
└─────────────────────────────────────────────────────────┘
                         │
                         │ Passed to DAG nodes
                         ▼
┌─────────────────────────────────────────────────────────┐
│              DAG VALIDATION LAYER                        │
│                                                          │
│  ExecutionGraph.validate()                              │
│  └── _is_dynamic_schema()  ◄──── INTROSPECTION         │
│      • Checks len(model_fields) == 0                    │
│      • Checks model_config.get('extra') == 'allow'      │
│      • REVERSE-ENGINEERS what is_dynamic already knows  │
│                                                          │
│  Problem: SchemaConfig dropped, must recreate knowledge │
└─────────────────────────────────────────────────────────┘
```

### The Architectural Flaw

**Knowledge Duplication:**
1. **Definition encoded in TWO places:**
   - `SchemaConfig.from_dict()` sets `is_dynamic=True` when `fields == "dynamic"`
   - `_is_dynamic_schema()` reverse-engineers this by checking `model_fields == {}` and `extra == 'allow'`

2. **Divergence risk:**
   - If `schema_factory._create_dynamic_schema()` changes implementation
   - Or if we add a new schema mode with empty fields
   - Then `_is_dynamic_schema()` will silently fail

3. **Coupling to Pydantic internals:**
   - `model_config.get('extra')` depends on Pydantic's ConfigDict structure
   - If Pydantic v3 changes how config is stored, this breaks
   - Not using a stable public API - introspecting implementation details

**Information Loss:**
```
SchemaConfig (has is_dynamic)
    ↓ create_schema_from_config()
type[PluginSchema] (loses is_dynamic metadata)
    ↓ stored in NodeInfo
ExecutionGraph (must recreate is_dynamic via introspection)
```

The metadata exists at config time but is **thrown away** during Pydantic model creation.

## Impact

### Immediate Impact (Low)
- Current implementation works correctly
- All tests pass
- Functionally equivalent to having SchemaConfig

### Medium-term Impact (Medium)
- **Maintenance burden:** Two places to update when schema logic changes
- **Fragility:** Pydantic upgrade could break detection silently
- **Cognitive load:** Developers must understand introspection pattern vs explicit flag
- **Test complexity:** Must test both `SchemaConfig.is_dynamic` AND introspection correctness

### Long-term Impact (High)
- **Architectural decay:** Sets precedent for lossy information flow
- **Coupling accumulation:** More code will depend on Pydantic internals
- **Bug surface area:** Each parallel mechanism is another place for bugs
- **Refactoring resistance:** Changes to schema representation require updating both layers

### Specific Risks

**Risk 1: Pydantic Upgrade Breakage**
```python
# Current Pydantic v2 structure:
schema.model_config  # ConfigDict object
schema.model_config.get('extra')  # 'allow' or 'forbid'

# Hypothetical Pydantic v3 change:
schema.model_config  # Now a frozen dataclass
schema.model_config.extra  # Direct attribute access
# ❌ .get() returns None, detection breaks silently
```

**Risk 2: Schema Mode Extension**
```python
# Future: Add "lenient" mode (some fields required, extras allowed)
SchemaConfig(
    mode="lenient",
    fields=[FieldDefinition(name="id", type="str")],
    is_dynamic=False  # Not dynamic! Has required fields
)

# But Pydantic model has:
# model_fields == {'id': FieldInfo(...)}  # Non-empty
# model_config['extra'] == 'allow'  # Allows extra

# _is_dynamic_schema() correctly returns False (has fields)
# BUT if we added mode="lenient" with NO required fields:
# model_fields == {}  # Empty (no required fields)
# model_config['extra'] == 'allow'
# ❌ _is_dynamic_schema() returns True (incorrect!)
```

**Risk 3: Factory Implementation Change**
```python
# Current factory:
def _create_dynamic_schema(name: str):
    return create_model(name, __config__=ConfigDict(extra='allow'))

# Future optimization (hypothetical):
# Cache dynamic schema class, reuse for all dynamic configs
_DYNAMIC_SCHEMA_CACHE = create_model("DynamicSchema", ...)

def _create_dynamic_schema(name: str):
    return _DYNAMIC_SCHEMA_CACHE  # Reuse cached class

# Works fine, BUT if we add marker:
class CachedDynamic(PluginSchema):
    model_config = ConfigDict(extra='allow')

_DYNAMIC_SCHEMA_CACHE = CachedDynamic

# Introspection still works, but now we have 3 representations!
# Creating more parallel mechanisms compounds the problem
```

## Evidence

### Code Review Findings (axiom-system-architect:architecture-critic)

**Overall Assessment:** "NEEDS REVISION"
**Quality Score:** 2/5
**Verdict:** "Valid short-term fix that unblocks RC-1 testing, but should be flagged as tech debt"

**HIGH Severity Issue #1: Redundant Detection Mechanisms**

From review session (agent a21a5df):

> Two separate representations of "dynamic" exist in the codebase:
>
> 1. `SchemaConfig.is_dynamic` (source of truth, explicit boolean)
>    - Used by plugins at: `csv_sink.py:118`, `database_sink.py:221`, `json_sink.py:113`
> 2. `_is_dynamic_schema()` (new, introspects Pydantic model)
>    - Checks `len(schema.model_fields) == 0` and `schema.model_config.get("extra") == "allow"`
>
> **Impact:**
> - Divergence risk: If `schema_factory.py` changes how dynamic schemas are created, `_is_dynamic_schema()` will fail silently
> - Knowledge duplication: The definition of "dynamic" is encoded in two places
> - Maintenance burden: Future maintainers must update both locations

**HIGH Severity Issue #2: Pydantic Implementation Coupling**

From review session (agent a21a5df):

> `_is_dynamic_schema()` depends on Pydantic's internal structure:
> ```python
> return (
>     len(schema.model_fields) == 0
>     and schema.model_config.get("extra") == "allow"
> )
> ```
>
> **Brittleness:**
> - `model_config.get("extra")` depends on Pydantic's `ConfigDict` structure
> - If Pydantic changes how `extra` is stored, this breaks
> - Not using a stable public API

**Recommendation from Critic:**

> If propagating `SchemaConfig` is not feasible, use a formal marker:
> ```python
> class DynamicSchemaMarker(PluginSchema):
>     """Marker base class for dynamic schemas."""
>     pass
>
> def _is_dynamic_schema(schema: type[PluginSchema] | None) -> bool:
>     if schema is None:
>         return True
>     return issubclass(schema, DynamicSchemaMarker)
> ```
>
> This creates an explicit contract rather than reverse-engineering Pydantic internals.

### Current Detection Usage (Codebase Analysis)

**SchemaConfig.is_dynamic usage (10 locations):**
```bash
src/elspeth/plugins/sinks/csv_sink.py:118:        if self._validate_input and not self._schema_config.is_dynamic:
src/elspeth/plugins/sinks/csv_sink.py:209:        if not self._schema_config.is_dynamic and self._schema_config.fields:
src/elspeth/plugins/sinks/database_sink.py:173:        if not self._schema_config.is_dynamic and self._schema_config.fields:
src/elspeth/plugins/sinks/database_sink.py:221:        if self._validate_input and not self._schema_config.is_dynamic:
src/elspeth/plugins/sinks/json_sink.py:113:        if self._validate_input and not self._schema_config.is_dynamic:
src/elspeth/plugins/transforms/passthrough.py:84:        if self._validate_input and not self._schema_config.is_dynamic:
src/elspeth/plugins/transforms/field_mapper.py:99:        if self._validate_input and not self._schema_config.is_dynamic:
src/elspeth/plugins/schema_factory.py:70:    if config.is_dynamic:
src/elspeth/core/landscape/recorder.py:514:        if schema_config.is_dynamic:
```

**_is_dynamic_schema() usage (2 locations):**
```bash
src/elspeth/core/dag.py:266:            if not _is_dynamic_schema(schema):
src/elspeth/core/dag.py:316:            if _is_dynamic_schema(producer_schema) or _is_dynamic_schema(consumer_schema):
```

**Pattern:** Plugins have access to `SchemaConfig`, DAG layer does not.

## Root Cause Analysis

### Why We Lost SchemaConfig

**Graph Construction Flow:**

```python
# src/elspeth/core/dag.py:523-531 (from_plugin_instances)
transform_cls = manager.get_transform_by_name(plugin_config.plugin)

# Get schemas from CLASS ATTRIBUTES
input_schema = getattr(transform_cls, "input_schema", None)
output_schema = getattr(transform_cls, "output_schema", None)

graph.add_node(
    tid,
    input_schema=input_schema,   # Pydantic model class
    output_schema=output_schema,  # Pydantic model class
)
```

**What's available at this point:**
- ✅ `plugin_config.plugin` (str) - plugin name
- ✅ `plugin_config.options` (dict) - config options
- ✅ `transform_cls` (type) - plugin class
- ✅ `transform_cls.input_schema` (type[PluginSchema]) - Pydantic model
- ❌ `SchemaConfig` - NOT available (not stored on class)

**Why SchemaConfig isn't available:**
```python
# src/elspeth/plugins/transforms/passthrough.py:__init__
def __init__(self, config: dict[str, Any]) -> None:
    super().__init__(config)
    self._schema_config = SchemaConfig.from_dict(config.get("schema", {}))

    # Schemas attached to INSTANCE
    self.input_schema = create_schema_from_config(self._schema_config, ...)
    self.output_schema = create_schema_from_config(self._schema_config, ...)
```

- `_schema_config` is an **instance attribute**, not class attribute
- Graph construction uses `getattr(transform_cls, "input_schema")` on the **class**
- To get `_schema_config`, would need to instantiate: `transform_cls(config.options)`
- But plugins aren't instantiated during graph validation (happens later in Orchestrator)

### The Design Tension

**Requirement 1:** Validate graph before instantiating plugins
- Don't want to instantiate plugins just to validate (expensive)
- External API calls, database connections in `__init__()` would fail
- Validation should be cheap and side-effect-free

**Requirement 2:** Schemas are instance attributes
- Plugins receive config in `__init__()`, extract schema from config
- `SchemaConfig.from_dict(config["schema"])` happens at instantiation
- Can't access instance attributes without instantiating

**Tension:** Need schema metadata (is_dynamic) without instantiating plugins

### Why Current Approach is Suboptimal

**Current:** Introspect Pydantic model to recreate `is_dynamic` information

**Problems:**
1. Information exists (in config) but is thrown away (during Pydantic model creation)
2. Must reverse-engineer from Pydantic structure
3. Couples to Pydantic implementation
4. Duplicates logic (SchemaConfig.is_dynamic vs introspection)

**Better:** Preserve `is_dynamic` metadata through the pipeline

## Proposed Solutions

### Option A: Propagate SchemaConfig to DAG Nodes (RECOMMENDED)

**Architecture:**
```
SchemaConfig (config layer)
    ↓
type[PluginSchema] (Pydantic layer)
    ↓
NodeInfo stores BOTH ◄─── Preserve metadata
    ├── input_schema: type[PluginSchema]
    ├── output_schema: type[PluginSchema]
    ├── input_schema_config: SchemaConfig | None  ◄─── NEW
    └── output_schema_config: SchemaConfig | None ◄─── NEW
```

**Implementation:**

**Step 1:** Extend `NodeInfo` dataclass
```python
# src/elspeth/core/dag.py:26-37
@dataclass
class NodeInfo:
    node_id: str
    node_type: str
    plugin_name: str
    config: dict[str, Any]
    input_schema: type[PluginSchema] | None
    output_schema: type[PluginSchema] | None
    input_schema_config: SchemaConfig | None = None   # NEW
    output_schema_config: SchemaConfig | None = None  # NEW
```

**Step 2:** Update graph construction to extract SchemaConfig
```python
# src/elspeth/core/dag.py:from_plugin_instances() (transforms)
for seq, plugin_config in enumerate(config.row_plugins):
    transform_cls = manager.get_transform_by_name(plugin_config.plugin)

    # Extract SchemaConfig from plugin config
    schema_config = SchemaConfig.from_dict(
        plugin_config.options.get("schema", {})
    )

    # Get Pydantic schemas from class attributes
    input_schema = getattr(transform_cls, "input_schema", None)
    output_schema = getattr(transform_cls, "output_schema", None)

    graph.add_node(
        tid,
        input_schema=input_schema,
        output_schema=output_schema,
        input_schema_config=schema_config,   # NEW - both input and output
        output_schema_config=schema_config,  # NEW   use same config
    )
```

**Step 3:** Update validation to use SchemaConfig
```python
# src/elspeth/core/dag.py:_validate_edge_schemas()
producer_info = self.get_node_info(edge.from_node)
consumer_info = self.get_node_info(edge.to_node)

# Check if either is dynamic using SchemaConfig (source of truth)
producer_is_dynamic = (
    producer_info.output_schema_config is not None
    and producer_info.output_schema_config.is_dynamic
)
consumer_is_dynamic = (
    consumer_info.input_schema_config is not None
    and consumer_info.input_schema_config.is_dynamic
)

# Skip validation if either is dynamic
if producer_is_dynamic or consumer_is_dynamic:
    continue
```

**Step 4:** Remove `_is_dynamic_schema()` helper (no longer needed)

**Benefits:**
- ✅ Single source of truth (`SchemaConfig.is_dynamic`)
- ✅ No introspection of Pydantic internals
- ✅ No Pydantic version coupling
- ✅ Explicit rather than inferred
- ✅ Self-documenting (NodeInfo shows what metadata is available)

**Costs:**
- ❌ Larger refactor (update NodeInfo, both graph construction methods, all validation)
- ❌ Must extract SchemaConfig in both `from_config()` and `from_plugin_instances()`
- ❌ Potential serialization impact if graphs are pickled/checkpointed

**Estimated Effort:** 4-6 hours (medium refactor)

---

### Option B: Marker Base Class Pattern (ALTERNATIVE)

**Architecture:**
```
SchemaConfig.is_dynamic == True
    ↓ schema_factory._create_dynamic_schema()
class DynamicSchemaXYZ(DynamicSchemaMarker):  ◄─── Explicit marker
    model_config = ConfigDict(extra='allow')
    ↓
DAG validation checks:
    issubclass(schema, DynamicSchemaMarker)  ◄─── Explicit contract
```

**Implementation:**

**Step 1:** Add marker base class
```python
# src/elspeth/plugins/schema_factory.py:~20
class DynamicSchemaMarker(PluginSchema):
    """Marker base class for dynamic schemas.

    Dynamic schemas accept any fields without validation.
    Used to signal to DAG validation that schema compatibility
    should be skipped for this schema.
    """
    pass
```

**Step 2:** Update dynamic schema creation to use marker
```python
# src/elspeth/plugins/schema_factory.py:78-91
def _create_dynamic_schema(name: str) -> type[PluginSchema]:
    """Create a schema that accepts any fields."""
    return create_model(
        name,
        __base__=DynamicSchemaMarker,  # Changed from PluginSchema
        __module__=__name__,
        __config__=ConfigDict(
            extra="allow",
        ),
    )
```

**Step 3:** Update detection to use marker check
```python
# src/elspeth/core/dag.py:68-85
def _is_dynamic_schema(schema: type[PluginSchema] | None) -> bool:
    """Check if a schema is dynamic (accepts any fields).

    Dynamic schemas inherit from DynamicSchemaMarker base class.

    Args:
        schema: Schema class to check (None is treated as dynamic for backwards compat)

    Returns:
        True if schema is dynamic or None, False if explicit schema
    """
    if schema is None:
        return True  # Backwards compatibility

    # Use explicit marker interface instead of introspection
    return issubclass(schema, DynamicSchemaMarker)
```

**Benefits:**
- ✅ Explicit contract (marker interface pattern)
- ✅ Standard Python idiom (`isinstance`/`issubclass`)
- ✅ No Pydantic coupling (uses inheritance)
- ✅ Self-documenting (`DynamicSchemaMarker` name is clear)
- ✅ Smaller change (only schema_factory and detection helper)

**Costs:**
- ❌ Adds inheritance layer
- ❌ Still doesn't address root issue (SchemaConfig metadata lost)
- ❌ Marker pattern may be unfamiliar to some developers
- ⚠️ Still two representations (SchemaConfig.is_dynamic + marker class)

**Estimated Effort:** 1-2 hours (small refactor)

---

### Option C: Hybrid Approach (FALLBACK)

**Use marker class SHORT-TERM, migrate to SchemaConfig LONG-TERM**

**Phase 1 (Post-RC-1):** Implement Option B (marker class)
- Quick win: Eliminates Pydantic coupling
- Buys time for larger refactor

**Phase 2 (Post-RC-2):** Migrate to Option A (SchemaConfig propagation)
- Proper architectural fix
- Eliminates all redundancy

**Benefits:**
- ✅ Incremental improvement
- ✅ Each phase delivers value
- ✅ Lower risk (smaller changes per phase)

**Costs:**
- ❌ Two refactorings instead of one
- ❌ Temporary marker class becomes tech debt

---

## Recommendation

**For Post-RC-1:** **Option A** (Propagate SchemaConfig)

**Rationale:**
1. **Single source of truth** - Eliminates redundancy completely
2. **Future-proof** - Not coupled to Pydantic internals
3. **Architectural clarity** - NodeInfo explicitly shows what metadata is available
4. **One-time cost** - Medium refactor now vs accumulating small fixes later

**Option B (marker class) is acceptable if:**
- Time pressure prevents medium refactor
- Need quick improvement before larger architectural work
- Planning to revisit schema architecture comprehensively later

**Migration Path (if Option B chosen first):**
1. Post-RC-1: Implement marker class (1-2 hours)
2. Post-RC-2: Plan comprehensive schema architecture review
3. Post-RC-3: Migrate to SchemaConfig propagation (4-6 hours)

## Implementation Plan

### Option A: SchemaConfig Propagation (Recommended)

**Phase 1: Extend NodeInfo (30 min)**
- [ ] Add `input_schema_config: SchemaConfig | None` field
- [ ] Add `output_schema_config: SchemaConfig | None` field
- [ ] Update type hints in all NodeInfo consumers

**Phase 2: Update from_plugin_instances() (1 hour)**
- [ ] Sources: Extract SchemaConfig from `plugin_config.options["schema"]`
- [ ] Transforms: Extract SchemaConfig from `plugin_config.options["schema"]`
- [ ] Aggregations: Extract SchemaConfig from `plugin_config.options["schema"]`
- [ ] Sinks: Extract SchemaConfig from `plugin_config.options["schema"]`
- [ ] Pass SchemaConfig to `add_node()` calls

**Phase 3: Update from_config() (1 hour)**
- [ ] Same extractions as Phase 2
- [ ] Ensure both construction paths use identical logic
- [ ] Consider extracting helper: `_extract_schema_config(options: dict) -> SchemaConfig`

**Phase 4: Update validation logic (1 hour)**
- [ ] `_validate_edge_schemas()`: Use `schema_config.is_dynamic` instead of `_is_dynamic_schema()`
- [ ] `_validate_coalesce_schema_compatibility()`: Use `schema_config.is_dynamic`
- [ ] Remove `_is_dynamic_schema()` helper function
- [ ] Update comments explaining why SchemaConfig is checked

**Phase 5: Update tests (1 hour)**
- [ ] Unit tests: Verify SchemaConfig properly propagated to nodes
- [ ] Integration tests: Verify validation still works correctly
- [ ] Add test: Ensure both construction paths produce equivalent NodeInfo
- [ ] Remove tests that specifically tested `_is_dynamic_schema()` helper

**Phase 6: Update documentation (30 min)**
- [ ] Update NodeInfo docstring explaining new fields
- [ ] Update validation docstrings (no longer introspecting)
- [ ] Add ADR documenting why SchemaConfig is propagated
- [ ] Update CLAUDE.md if schema architecture is documented there

**Total Estimated Time:** 5 hours

---

### Option B: Marker Class (Alternative)

**Phase 1: Add marker base class (15 min)**
- [ ] Create `DynamicSchemaMarker(PluginSchema)` in schema_factory.py
- [ ] Add comprehensive docstring

**Phase 2: Update schema creation (15 min)**
- [ ] Modify `_create_dynamic_schema()` to use DynamicSchemaMarker as base
- [ ] Verify all dynamic schemas inherit from marker

**Phase 3: Update detection logic (15 min)**
- [ ] Replace introspection in `_is_dynamic_schema()` with `issubclass()` check
- [ ] Update docstring explaining marker pattern
- [ ] Keep backwards compatibility with `None`

**Phase 4: Update tests (30 min)**
- [ ] Verify detection still works for dynamic schemas
- [ ] Add test: Marker class inheritance verified
- [ ] Add test: issubclass check works correctly

**Phase 5: Update documentation (15 min)**
- [ ] Add comment explaining marker pattern
- [ ] Document why this is better than introspection
- [ ] Flag as intermediate solution if migrating to Option A later

**Total Estimated Time:** 1.5 hours

---

## Verification Criteria

### Functional Verification
- [ ] All 3,279+ tests pass
- [ ] Dynamic → specific schema edges skip validation
- [ ] Specific → dynamic schema edges skip validation
- [ ] Explicit schema validation still catches incompatibilities
- [ ] Coalesce nodes correctly skip dynamic schemas

### Architectural Verification
- [ ] Only ONE detection mechanism exists (either SchemaConfig or marker)
- [ ] No Pydantic introspection for dynamic detection
- [ ] `.get()` on `model_config` removed (if Option A)
- [ ] Single source of truth clearly documented

### Quality Verification
- [ ] Architecture critic review: Score improves from 2/5
- [ ] Code reviewer confirms no new tech debt introduced
- [ ] mypy clean
- [ ] ruff clean
- [ ] no_bug_hiding.yaml allowlist reduced (if Option A)

## Success Metrics

**Before (Current State):**
- 2 detection mechanisms (SchemaConfig.is_dynamic + introspection)
- Architecture quality: 2/5
- Pydantic coupling: HIGH
- Maintenance locations: 2 (SchemaConfig.from_dict + _is_dynamic_schema)

**After (Option A - Target State):**
- 1 detection mechanism (SchemaConfig.is_dynamic only)
- Architecture quality: 4-5/5
- Pydantic coupling: NONE (for detection)
- Maintenance locations: 1 (SchemaConfig.from_dict)

**After (Option B - Intermediate State):**
- 2 detection mechanisms (SchemaConfig.is_dynamic + marker class)
- Architecture quality: 3/5
- Pydantic coupling: LOW (only for schema creation, not detection)
- Maintenance locations: 2 (SchemaConfig.from_dict + marker inheritance)

## Risks

### Option A Risks

**Risk 1: Serialization Impact**
- If graphs are pickled/checkpointed, SchemaConfig must be serializable
- **Mitigation:** SchemaConfig is a Pydantic model (already serializable)
- **Test:** Add serialization test for NodeInfo with SchemaConfig

**Risk 2: from_config() Divergence**
- Both construction paths must extract SchemaConfig identically
- **Mitigation:** Extract to helper `_extract_schema_config(options)`
- **Test:** Add test verifying both paths produce equivalent NodeInfo

**Risk 3: Breaking Change**
- NodeInfo dataclass change affects any code that constructs graphs manually
- **Mitigation:** Make new fields optional (default to None)
- **Test:** Verify existing tests don't break with new fields

### Option B Risks

**Risk 1: Marker Not Applied**
- If future code creates dynamic schemas without using factory
- **Mitigation:** Document that `_create_dynamic_schema()` is the only way
- **Test:** Add test verifying all dynamic schemas inherit marker

**Risk 2: Still Redundant**
- Doesn't eliminate parallel mechanisms, just makes one less fragile
- **Mitigation:** Plan migration to Option A for future sprint
- **Document:** Flag as intermediate solution in code comments

## Related Issues

- **Fixed by this ticket:** Architectural debt from P0-2026-01-24-dynamic-schema-detection-regression
- **Introduced by:** P0-2026-01-24-dynamic-schema-detection-regression fix (introspection approach)
- **Blocks:** Future schema-related features (new modes, schema evolution)
- **Parent issue:** P0-2026-01-24-schema-validation-non-functional (original architectural fix)

## References

### Architecture Review

- Review agent: a21a5df (axiom-system-architect:architecture-critic)
- Quality score: 2/5
- Assessment: "NEEDS REVISION - Valid short-term fix, flag as tech debt"
- HIGH issues: 2 (redundant mechanisms, Pydantic coupling)

### Code Locations

**Current introspection approach:**
- Helper: `src/elspeth/core/dag.py:68-85` (_is_dynamic_schema)
- Usage 1: `src/elspeth/core/dag.py:266`
- Usage 2: `src/elspeth/core/dag.py:316`

**Source of truth:**
- SchemaConfig: `src/elspeth/contracts/schema.py:180` (is_dynamic field)
- Factory: `src/elspeth/plugins/schema_factory.py:70` (checks is_dynamic)

**Plugin usage (10 locations):**
- All use `self._schema_config.is_dynamic` (correct pattern)

### Documentation

- Parent bug ticket: `docs/bugs/P0-2026-01-24-dynamic-schema-detection-regression.md`
- CLAUDE.md: "No Bug-Hiding Patterns" policy
- CLAUDE.md: "No Legacy Code Policy"

## Timeline

- **2026-01-24 15:00** - Architecture review identifies tech debt (2/5 score)
- **2026-01-24 16:00** - Parent bug ticket documents issue
- **2026-01-24 17:15** - This technical debt ticket created
- **Target: Post-RC-1** - Implement Option A or B
- **Target: Post-RC-2** - If Option B chosen, migrate to Option A

## Resolution Criteria

**This ticket is RESOLVED when:**
- [ ] Architecture critic review scores 4+/5
- [ ] Only ONE dynamic detection mechanism exists
- [ ] No Pydantic introspection for detection (unless using Pydantic's public API)
- [ ] All tests pass
- [ ] Documentation updated

**Acceptance Criteria:**
- [ ] Either Option A (SchemaConfig propagation) OR Option B (marker class) implemented
- [ ] `_is_dynamic_schema()` either removed (Option A) or simplified to marker check (Option B)
- [ ] Technical debt ticket closed or follow-up created (if Option B)

---

## Resolution

**Status:** ✅ **RESOLVED** (commit: 0a339fd)

**Implementation:** ROOT CAUSE FIX - Moved validation to plugin construction

**What Changed:**
1. Schema validation moved from DAG layer to plugin construction
2. DAG.validate() only checks structural issues (cycles, connectivity)
3. Plugins validate their own schemas during __init__()
4. Deleted _is_dynamic_schema(), _validate_edge_schemas(), etc.
5. No SchemaConfig propagation to NodeInfo (not needed)

**Architecture Improvement:**
- Before: 2/5 (parallel mechanisms, Pydantic coupling)
- After: 5/5 (single source of truth, validation at right layer)

**Eliminated:**
- Parallel detection mechanisms (2 → 0, validation happens once)
- Pydantic introspection (minimal, only for dynamic schema detection)
- NodeInfo bloat (avoided, no new fields)
- Information loss pattern (fixed, config stays with plugin)

**Implemented:** 2026-01-25
**Implementation Plan:** docs/plans/2026-01-24-fix-schema-validation-properly.md

---

**Ticket Status:** RESOLVED
**Priority:** P0 (high-impact architectural debt)
**Resolution Date:** 2026-01-25
**Resolution Approach:** Root cause fix (better than Options A or B)
