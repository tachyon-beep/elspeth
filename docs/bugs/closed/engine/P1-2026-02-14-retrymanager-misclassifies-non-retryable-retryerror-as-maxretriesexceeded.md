## Summary

`RetryManager.execute_with_retry()` can misclassify a non-retryable `tenacity.RetryError` raised by the operation as `MaxRetriesExceeded`, converting a programming/integration error into a row-scoped retry exhaustion.

## Severity

- Severity: major
- Priority: P1

## Location

- File: `/home/john/elspeth-rapid/src/elspeth/engine/retry.py`
- Line(s): 133-135, 137-143
- Function/Method: `RetryManager.execute_with_retry`

## Evidence

`RetryManager` catches all `Exception` from `operation()` and stores it in `last_error`, then has a broad outer `except RetryError` that always wraps into `MaxRetriesExceeded`:

- `/home/john/elspeth-rapid/src/elspeth/engine/retry.py:133-135`
- `/home/john/elspeth-rapid/src/elspeth/engine/retry.py:137-143`

This conflates two different cases:

1. Tenacity's internal exhaustion wrapper (`RetryError` generated by tenacity)
2. A `RetryError` thrown directly by `operation()` (non-retryable user/plugin exception)

I verified behavior with a direct runtime check: when `operation()` raises `RetryError` and `is_retryable` returns `False`, `execute_with_retry()` still raises `MaxRetriesExceeded(attempts=1, last_error=RetryError(...))` instead of re-raising the original non-retryable exception.

Downstream impact is visible here:

- `/home/john/elspeth-rapid/src/elspeth/engine/processor.py:1609-1634` catches `MaxRetriesExceeded` and records `RowOutcome.FAILED`, allowing pipeline continuation instead of crashing on plugin bug as required by CLAUDE.md plugin-ownership rules.

## Root Cause Hypothesis

The target file uses exception class (`RetryError`) as the sole discriminator for "retry exhaustion," but the same class can also originate from the wrapped operation. The broad `except RetryError` in `retry.py` therefore over-captures and rewrites non-retryable exceptions.

## Suggested Fix

In `retry.py`, only wrap `RetryError` when it is tenacity's exhaustion wrapper, not when it is the original operation exception. Minimal guard in target file:

```python
except RetryError as e:
    # Operation raised RetryError directly (non-retryable) -> preserve original behavior
    if last_error is e:
        raise

    final_error = last_error or e.last_attempt.exception()
    if final_error is None:
        raise RuntimeError("RetryError raised without captured exception") from e
    raise MaxRetriesExceeded(attempt, final_error) from e
```

Also add a regression test in `tests/unit/engine/test_retry.py`:
- operation raises `RetryError`
- `is_retryable` returns `False`
- assert original `RetryError` is re-raised (not `MaxRetriesExceeded`)

## Impact

- Violates contract semantics: non-retryable/plugin bugs can be mislabeled as retry exhaustion.
- Violates architecture policy: plugin bugs should crash, not be silently downgraded to row-level `FAILED`.
- Can produce incorrect audit narratives (`MaxRetriesExceeded`) and continue processing with partial bad behavior instead of fail-fast.

## Triage

- Status: closed (false positive)
- Reason: tenacity with `reraise=False` re-raises non-retryable exceptions directly â€” it does NOT wrap them in RetryError. No plugin in the codebase raises `tenacity.RetryError`. The claimed misclassification path is unreachable.
- Source report: `docs/bugs/generated/engine/retry.py.md`
