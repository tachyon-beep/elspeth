# Bug Report: Token outcomes use synthetic fork/join/expand group IDs that don't match tokens table

## Summary

- `LandscapeRecorder` generates and stores `fork_group_id`, `join_group_id`, and `expand_group_id` on token records when forking/coalescing/expanding.
- `TokenManager` discards those group IDs when returning `TokenInfo`, and `RowProcessor` generates new random IDs when recording token outcomes.
- As a result, `token_outcomes.{fork,join,expand}_group_id` does not match the group IDs recorded on the tokens themselves, breaking lineage grouping and audit consistency.

## Severity

- Severity: major
- Priority: P1

## Reporter

- Name or handle: codex
- Date: 2026-01-21
- Related run/issue ID: N/A

## Environment

- Commit/branch: `ae2c0e6f088f467276582fa8016f91b4d3bb26c7` (local)
- OS: Linux (Ubuntu kernel 6.8.0-90-generic)
- Python version: 3.13.1
- Config profile / env vars: N/A
- Data set or fixture: N/A

## Agent Context (if relevant)

- Goal or task prompt: deep dive into `src/elspeth/engine/tokens.py` and create bug tickets
- Model/version: GPT-5 (Codex CLI)
- Tooling and permissions (sandbox/approvals): workspace-write, network restricted, approvals on-request
- Determinism details (seed, run ID): N/A
- Notable tool calls or steps: static inspection of token manager, recorder, and row processor

## Steps To Reproduce

1. Run a pipeline that includes a fork (gate) or a transform that returns `TransformResult.success_multi()`.
2. Inspect `tokens` and `token_outcomes` tables for the affected token.
3. Observe that `tokens.fork_group_id` / `tokens.expand_group_id` / `tokens.join_group_id` do not match the corresponding fields in `token_outcomes`.

## Expected Behavior

- `token_outcomes.{fork,join,expand}_group_id` should match the group IDs recorded on tokens created by the recorder.

## Actual Behavior

- Token outcomes use fresh random IDs unrelated to the token group IDs generated by `LandscapeRecorder`.

## Evidence

- `LandscapeRecorder.fork_token()`/`coalesce_tokens()`/`expand_token()` generate and store group IDs on tokens: `src/elspeth/core/landscape/recorder.py`.
- `TokenManager` returns `TokenInfo` without group IDs, dropping the recorder values: `src/elspeth/engine/tokens.py`.
- `RowProcessor` generates new UUIDs for token outcomes:
  - Fork: `src/elspeth/engine/processor.py` (random `fork_group_id`)
  - Expand: `src/elspeth/engine/processor.py` (random `expand_group_id`)
  - Coalesce: `src/elspeth/engine/processor.py` (random `join_group_id`)

## Impact

- User-facing impact: lineage grouping for forks/expands/coalesces is inconsistent between token records and outcomes.
- Data integrity / security impact: audit trail cannot reliably correlate outcome grouping with actual token lineage; violates traceability expectations.
- Performance or cost impact: low.

## Root Cause Hypothesis

- Group IDs are generated in the recorder but are not exposed through `TokenInfo`, forcing the processor to invent new IDs for outcome recording.

## Proposed Fix

- Code changes (modules/files):
  - Extend `TokenInfo` to include `fork_group_id`, `join_group_id`, and `expand_group_id`.
  - Update `TokenManager.fork_token()` / `coalesce_tokens()` / `expand_token()` to populate these fields from recorder-returned `Token` objects.
  - Update `RowProcessor` to use these group IDs when calling `record_token_outcome()`.
- Config or schema changes: none.
- Tests to add/update:
  - Add an integration test that creates forked/expanded/coalesced tokens and asserts `token_outcomes` group IDs match `tokens` group IDs.
- Risks or migration steps:
  - Ensure any existing reports or exporters referencing token outcomes account for the corrected IDs.

## Architectural Deviations

- Spec or doc reference (e.g., docs/design/architecture.md#L...): `docs/design/subsystems/00-overview.md` (group IDs link tokens from the same fork/coalesce/expand).
- Observed divergence: token outcomes do not use the recorder-generated group IDs.
- Reason (if known): `TokenInfo` does not carry group IDs, so processor synthesizes them.
- Alignment plan or decision needed: decide canonical source for group IDs (tokens table) and propagate into outcomes.

## Acceptance Criteria

- For any fork/coalesce/expand, the group IDs recorded in `token_outcomes` match the group IDs stored on tokens.

## Tests

- Suggested tests to run: `.venv/bin/python -m pytest tests/engine/test_processor_outcomes.py -k group_id`
- New tests required: yes (group ID consistency)

## Notes / Links

- Related issues/PRs: N/A
- Related design docs: `docs/design/subsystems/00-overview.md`

---

## Verification (2026-01-24)

### Status: **STILL VALID**

### Verification Method

Code inspection of the complete flow from recorder → token manager → processor:

1. **LandscapeRecorder generates and stores group IDs** (`src/elspeth/core/landscape/recorder.py`):
   - `fork_token()` line 850: `fork_group_id = _generate_id()` - stored in tokens table (line 863)
   - `coalesce_tokens()` line 912: `join_group_id = _generate_id()` - stored in tokens table (line 922)
   - `expand_token()` line 977: `expand_group_id = _generate_id()` - stored in tokens table (line 990)

2. **TokenManager drops group IDs from TokenInfo** (`src/elspeth/engine/tokens.py`):
   - `fork_token()` lines 160-168: Creates `TokenInfo` with only `row_id`, `token_id`, `row_data`, `branch_name` - **no group IDs**
   - `coalesce_tokens()` lines 198-202: Creates `TokenInfo` without group IDs
   - `expand_token()` lines 254-262: Creates `TokenInfo` without group IDs

3. **RowProcessor generates synthetic group IDs** (`src/elspeth/engine/processor.py`):
   - Line 708: `fork_group_id = uuid.uuid4().hex[:16]` - **NEW ID, unrelated to recorder's ID**
   - Line 842: `expand_group_id = uuid.uuid4().hex[:16]` - **NEW ID, unrelated to recorder's ID**
   - Line 972: `join_group_id = f"{coalesce_name}_{uuid.uuid4().hex[:8]}"` - **NEW ID, unrelated to recorder's ID**

### Contract Analysis

**TokenInfo contract** (`src/elspeth/contracts/identity.py` lines 10-27):
```python
@dataclass
class TokenInfo:
    row_id: str
    token_id: str
    row_data: dict[str, Any]
    branch_name: str | None = None
```
**Missing fields**: `fork_group_id`, `join_group_id`, `expand_group_id`

**Token model** (`src/elspeth/core/landscape/models.py` lines 93-104):
```python
@dataclass
class Token:
    token_id: str
    row_id: str
    created_at: datetime
    fork_group_id: str | None = None
    join_group_id: str | None = None
    expand_group_id: str | None = None
    branch_name: str | None = None
    step_in_pipeline: int | None = None
```
**Has all group ID fields** - these are populated by recorder but not propagated to TokenInfo

### Evidence Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. LandscapeRecorder.fork_token()                                   │
│    - Generates: fork_group_id = "abc123" (example)                  │
│    - Stores in tokens table: fork_group_id = "abc123"               │
│    - Returns: Token(fork_group_id="abc123")                         │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. TokenManager.fork_token()                                        │
│    - Receives: Token(fork_group_id="abc123")                        │
│    - Returns: TokenInfo(fork_group_id=<NOT SET>)  ← DROPS GROUP ID  │
└────────────────────────┬────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. RowProcessor._process_single_token()                             │
│    - Receives: TokenInfo (no group ID)                              │
│    - Generates: fork_group_id = "xyz789" (NEW, UNRELATED)           │
│    - Records outcome: fork_group_id = "xyz789"                      │
└─────────────────────────────────────────────────────────────────────┘

RESULT:
  tokens.fork_group_id = "abc123"          ← Recorder's ID
  token_outcomes.fork_group_id = "xyz789"  ← Processor's synthetic ID

  ❌ MISMATCH: Cannot correlate outcomes with token lineage
```

### Git History Check

Searched for fixes related to group IDs:
- `git log --all --grep="group.id"` - Found commits adding group ID features (e93e56c, d941c25)
- `git log --all -S "fork_group_id"` - Found 20+ commits implementing group IDs
- **No commits found that fix the propagation gap**

Most recent relevant commit: **e93e56c** (2026-01-21) "feat(processor): record all outcome types for AUD-001"
- This commit ADDED the outcome recording with group IDs
- It generated NEW synthetic IDs instead of using recorder's IDs
- **This commit introduced/preserved the bug**

### Test Coverage Gap

Searched for tests validating group ID consistency:
- `tests/core/landscape/test_recorder.py` line 464: Tests that child tokens share same `fork_group_id` ✓
- **NO TESTS** verify `token_outcomes.fork_group_id` matches `tokens.fork_group_id`
- **NO TESTS** verify `token_outcomes.join_group_id` matches `tokens.join_group_id`
- **NO TESTS** verify `token_outcomes.expand_group_id` matches `tokens.expand_group_id`

### Root Cause Confirmed

The bug is a **contract propagation gap**:

1. `Token` (recorder model) has group IDs ✓
2. `TokenInfo` (engine contract) lacks group IDs ✗ ← **MISSING FIELDS**
3. Processor has no way to access recorder's group IDs
4. Processor generates synthetic IDs to satisfy outcome recording requirements

### Impact Assessment

**Audit Trail Integrity**: BROKEN
- Cannot query "show me all token outcomes for fork group X"
- Cannot correlate child tokens with parent fork outcome
- Lineage reconstruction requires manual token parent table queries
- Violates ELSPETH's "complete traceability" principle

**Workaround Exists**: YES
- Query `token_parents` table to reconstruct fork/expand/coalesce relationships
- Query `tokens` table for canonical group IDs
- **BUT**: Requires complex multi-table joins that should be unnecessary

### Conclusion

**Bug Status**: ~~STILL VALID as of commit 2c06ad5 (2026-01-24)~~ **FIXED as of 2026-01-27**

**Priority Justification**: P1 maintained
- Breaks audit trail consistency (core ELSPETH principle)
- Affects ALL pipelines with forks/expands/coalesces
- No data loss, but requires schema/code fix before RC2
- Has workaround via token_parents table

**Recommendation**: ~~Fix before RC2 release to prevent schema migration burden~~ Fixed.

---

## Closure (2026-01-27)

**Status: FIXED**

### Summary

The original bug was already fixed in the codebase, but a **secondary bug** was masking it:

1. **Original Bug (Group ID Mismatch)**: FIXED
   - `TokenInfo` now has group ID fields
   - `TokenManager` preserves group IDs from recorder
   - `RowProcessor` uses canonical group IDs from tokens

2. **Secondary Bug (TransformProtocol)**: FIXED 2026-01-27
   - Commit `a4a8eed` incorrectly added `routes`/`fork_to` to `TransformProtocol`
   - This broke `isinstance(transform, TransformProtocol)` for all transforms
   - Expand tests failed with `TypeError` instead of testing group IDs
   - Fix: Removed erroneous fields from `TransformProtocol`

### All Tests Pass

```
tests/engine/test_group_id_consistency.py::TestForkGroupIDConsistency::test_fork_children_share_same_fork_group_id_in_tokens_table PASSED
tests/engine/test_group_id_consistency.py::TestForkGroupIDConsistency::test_fork_parent_outcome_uses_canonical_fork_group_id PASSED
tests/engine/test_group_id_consistency.py::TestJoinGroupIDConsistency::test_coalesce_creates_merged_token_with_join_group_id PASSED
tests/engine/test_group_id_consistency.py::TestJoinGroupIDConsistency::test_coalesce_consumed_tokens_use_canonical_join_group_id PASSED
tests/engine/test_group_id_consistency.py::TestJoinGroupIDConsistency::test_coalesce_merged_token_outcome_uses_canonical_join_group_id PASSED
tests/engine/test_group_id_consistency.py::TestExpandGroupIDConsistency::test_expand_creates_consistent_group_id_across_all_children PASSED
tests/engine/test_group_id_consistency.py::TestExpandGroupIDConsistency::test_expand_parent_outcome_uses_canonical_expand_group_id PASSED
```

### Lesson Learned

Defensive `isinstance()` checks against malformed protocols hide bugs rather than catching them. The failing protocol check made it appear the original bug still existed when it was actually fixed.
